Got it üëç
This is a **classic problem**: Implementing a **Queue** (FIFO ‚Äì First In First Out) using **Stacks** (LIFO ‚Äì Last In First Out).

There are **two common approaches**:

---

## **Approach 1: Make `enqueue` costly**

* Always push into stack1.
* For `dequeue`, move elements from stack1 to stack2 (reverse order), pop from stack2.

---

## **Approach 2: Make `dequeue` costly** ‚úÖ (Most common)

* Push directly into stack1 (fast).
* For `dequeue`, if stack2 is empty, move everything from stack1 to stack2, then pop.

---

Here‚Äôs the **Java implementation (Approach 2 ‚Äì Efficient enqueue)**:

```java
import java.util.Stack;

public class QueueUsingStacks {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;

    public QueueUsingStacks() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    // Enqueue operation (O(1))
    public void enqueue(int data) {
        stack1.push(data);
    }

    // Dequeue operation (Amortized O(1), worst O(n))
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }

        // Move elements only if stack2 is empty
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }

    // Peek front element
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }

        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }

    // Check if queue is empty
    public boolean isEmpty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }

    public static void main(String[] args) {
        QueueUsingStacks q = new QueueUsingStacks();
        
        q.enqueue(10);
        q.enqueue(20);
        q.enqueue(30);

        System.out.println("Dequeued: " + q.dequeue()); // 10
        System.out.println("Peek: " + q.peek());        // 20
        System.out.println("Dequeued: " + q.dequeue()); // 20
        System.out.println("Dequeued: " + q.dequeue()); // 30
        System.out.println("Is Empty? " + q.isEmpty()); // true
    }
}
```

---

### ‚úÖ **Complexity**

* `enqueue`: **O(1)**
* `dequeue`: **Amortized O(1)** (because each element moves **once** from stack1 ‚Üí stack2).
* Space: **O(n)** (to store elements in two stacks).

---


### Operations:

### 1. **Enqueue (push into stack1)**

* Just a `push()` to stack1.
* **Time Complexity:** `O(1)`
* **Space Complexity:** `O(1)` extra (just storing one new element).

---

### 2. **Dequeue (pop from stack2)**

* If `stack2` is **not empty** ‚Üí Just `pop()` ‚Üí **O(1)**.
* If `stack2` is **empty** ‚Üí Move all elements from `stack1` ‚Üí `stack2`.

  * Each element is moved **once** from `stack1` to `stack2`.
  * So one transfer costs **O(n)** in worst case.

üëâ But here‚Äôs the trick: **Amortized analysis**

* Each element is transferred at most **once**.
* So across `m` operations, each element participates in **O(1)** moves.
* **Amortized Time:** `O(1)` per operation.
* **Worst-case Time:** `O(n)` (when transfer happens).

---

### 3. **Peek (front element)**

* Same as `dequeue` logic but without popping.
* **Amortized Time:** `O(1)`
* **Worst-case Time:** `O(n)` (if transfer happens).

---

### 4. **isEmpty**

* Just check if both stacks are empty.
* **Time Complexity:** `O(1)`

---

# üîπ **Space Complexity**

* We use **two stacks**.
* At most, all elements could be sitting in stack1 OR stack2.
* But **never duplicated** (since when moving, we pop from one and push to other).
* So total space = **O(n)** (where `n` = number of elements in the queue).

---

# üîπ **Summary Table**

| Operation | Worst-case Time | Amortized Time | Space      |
| --------- | --------------- | -------------- | ---------- |
| Enqueue   | O(1)            | O(1)           | O(1) extra |
| Dequeue   | O(n)            | O(1)           | O(1) extra |
| Peek      | O(n)            | O(1)           | O(1) extra |
| isEmpty   | O(1)            | O(1)           | O(1)       |
| Overall   | ‚Äî               | O(1) amortized | O(n)       |

---

‚úÖ So the implementation is **efficient in practice** because even though a single dequeue can cost `O(n)`, **most dequeues are O(1)** thanks to amortization.

---
