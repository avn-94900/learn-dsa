

## ðŸ”¹ **Idea (Floydâ€™s Cycle Detection)**

* Use **two pointers**:

  * `slow` â†’ moves **1 step** at a time.
  * `fast` â†’ moves **2 steps** at a time.
* If there is **no cycle**, `fast` will reach `null`.
* If there is a **cycle**, eventually `fast` and `slow` will **meet at the same node** inside the cycle.

---

## ðŸ”¹ **Java Implementation**

```java
public class LinkedListCycle {

    // 1ï¸âƒ£ Detect if there is a loop
    public static boolean hasCycle(ListNode head) {
        // Time Complexity: O(n)
        // Space Complexity: O(1)
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                return true; // loop detected
            }
        }
        return false;
    }

    // 2ï¸âƒ£ Find starting node of the loop
    public static ListNode findStartOfLoop(ListNode head) {
        // Time Complexity: O(n)
        // Space Complexity: O(1)
        ListNode slow = head;
        ListNode fast = head;

        // First detect loop
        boolean isCycle = false;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                isCycle = true;
                break;
            }
        }

        if (!isCycle) return null; // no loop

        // Move slow to head, then advance both one step at a time
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow; // start of loop
    }

    // 3ï¸âƒ£ Find length of the loop
    public static int loopLength(ListNode head) {
        // Time Complexity: O(n)
        // Space Complexity: O(1)
        ListNode slow = head;
        ListNode fast = head;

        // Detect loop
        boolean isCycle = false;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                isCycle = true;
                break;
            }
        }

        if (!isCycle) return 0; // no loop

        // Count nodes in loop
        int count = 1;
        ListNode current = slow.next;
        while (current != slow) {
            count++;
            current = current.next;
        }
        return count;
    }

    // 4ï¸âƒ£ Print cycle path
    public static void printCyclePath(ListNode head) {
        // Time Complexity: O(n)
        // Space Complexity: O(1)
        ListNode start = findStartOfLoop(head);
        if (start == null) {
            System.out.println("No loop in the linked list.");
            return;
        }

        System.out.print("Cycle path: ");
        ListNode current = start;
        do {
            System.out.print(current.val + " -> ");
            current = current.next;
        } while (current != start);
        System.out.println("(back to " + start.val + ")");
    }

    public static void main(String[] args) {
        // Create linked list with loop
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = head.next; // loop: 4 -> 2

        System.out.println("Has cycle? " + hasCycle(head)); // true
        System.out.println("Start of loop: " + findStartOfLoop(head).val); // 2
        System.out.println("Loop length: " + loopLength(head)); // 3
        printCyclePath(head); // 2 -> 3 -> 4 -> (back to 2)
    }
}
class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}
```

---

## ðŸ”¹ **Complexity Analysis**

* **Time Complexity:** `O(n)`

  * Each node is visited at most twice (by slow and fast).
* **Space Complexity:** `O(1)`

  * Only two pointers are used.

---

## ðŸ”¹ **Extensions**

1. If you need to **find the starting node of the loop**, after detecting, reset `slow = head` and move `slow` & `fast` one step at a time â€” theyâ€™ll meet at the start of the cycle.
2. If you need the **length of the loop**, keep moving `slow` until it meets `fast` again and count steps.

---

Do you want me to also add the **code for finding the starting node of the loop**, not just detecting it?
