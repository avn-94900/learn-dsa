# ðŸ”¢ Mathematical & Logical Puzzles

## Problem 1: Program to Add Two Fractions

### Problem Statement
Given two fractions represented by their numerators and denominators, add them and return the result in its simplest form. For example, adding 1/3 and 2/5 should give 11/15. The result should be reduced to lowest terms by dividing both numerator and denominator by their greatest common divisor (GCD).

Got it ðŸ‘
Letâ€™s prepare **clear notes** for all three:

1. **Brute force GCD**
2. **Euclidean Algorithm (Iterative & Recursive)**
3. **LCM using GCD**

Iâ€™ll explain in the same structured way with **steps (loop / recursion / formula)**.

---

# ðŸ“ Notes

---

## 1. GCD by Brute Force

### Code:

```java
static int gcdBruteForce(int a, int b) {
    int gcd = 1;
    for (int i = Math.min(a, b); i >= 1; i--) {
        if (a % i == 0 && b % i == 0) {
            gcd = i;
            break;
        }
    }
    return gcd;
}
```

### Logic:

* Start from the smaller of the two numbers.
* Keep checking downwards for the **largest number** that divides both `a` and `b`.
* The first one you find is the GCD.

### Example: gcd(18, 48)

* min(18, 48) = 18
* Check 18 â†’ (18 % 18 == 0, 48 % 18 != 0) âŒ
* Check 17 â†’ âŒ
* â€¦
* Check 6 â†’ (18 % 6 == 0, 48 % 6 == 0) âœ… â†’ gcd = 6

### âœ… Complexity:

* Time: **O(min(a, b))** (worst case checks all numbers)
* Space: **O(1)**

---

## 2. GCD by Euclidean Algorithm

### Recursive Code:

```java
static int gcdRecursive(int a, int b) {
    return (b == 0) ? a : gcdRecursive(b, a % b);
}
```

### Iterative Code:

```java
static int gcdIterative(int a, int b) {
    while (a != 0 && b != 0) {
        if (a > b) {
            a = a % b;
        } else {
            b = b % a;
        }
    }
    return (a != 0) ? a : b;
}
```

---

### Recursive Dry Run (Example gcd(18, 48)):

1. gcd(18, 48) â†’ gcd(48, 18)
2. gcd(48, 18) â†’ gcd(18, 12)
3. gcd(18, 12) â†’ gcd(12, 6)
4. gcd(12, 6) â†’ gcd(6, 0)
5. return 6 âœ…

---

### Iterative Dry Run (Example gcd(18, 48)):

* a = 18, b = 48
* a < b â†’ b = b % a â†’ b = 48 % 18 = 12
* a = 18, b = 12
* a > b â†’ a = a % b â†’ a = 18 % 12 = 6
* a = 6, b = 12
* a < b â†’ b = b % a â†’ b = 12 % 6 = 0
* loop ends â†’ return a = 6 âœ…

---

### âœ… Complexity:

* Time: **O(log(min(a, b)))** (much faster than brute force)
* Space:

  * Recursive: **O(log(min(a, b)))** (stack frames)
  * Iterative: **O(1)**

---

## 3. LCM using GCD

### Formula:

```
lcm(a, b) = (a * b) / gcd(a, b)
```

### Code:

```java
static int lcm(int a, int b) {
    return (a * b) / gcdIterative(a, b);  // or gcdRecursive
}
```

### Example: lcm(12, 18)

* gcd(12, 18) = 6
* lcm = (12 \* 18) / 6 = 216 / 6 = 36 âœ…

---

### âœ… Complexity:

* Same as GCD (because formula calls GCD once).
* Time: **O(log(min(a, b)))**
* Space: depends on GCD version used.

---

ðŸ“Œ **Quick Comparison Table**

| Method             | Time Complexity   | Space                    | Notes                             |
| ------------------ | ----------------- | ------------------------ | --------------------------------- |
| Brute Force GCD    | O(min(a, b))      | O(1)                     | Simple but slow for large numbers |
| Euclidean (Iter.)  | O(log(min(a, b))) | O(1)                     | Fast + no recursion overhead      |
| Euclidean (Recur.) | O(log(min(a, b))) | O(log(min(a, b)))        | Clean, but uses recursion stack   |
| LCM via GCD        | O(log(min(a, b))) | O(1) / O(log(min(a, b))) | Depends on GCD implementation     |

---

Got it ðŸ‘
Letâ€™s solve **"Add two fractions"** in **Java** using both **brute force** and **optimized approaches**, with explanations and complexities.

---

## Problem:

Given two fractions `a/b` and `c/d`, add them and return the result in **simplest form**.

Example:

```
Input: 1/2 + 3/4
Output: 5/4
```

```
Input: 1/3 + 1/6
Output: 1/2
```

---

## ðŸ”¹ Brute Force Approach

ðŸ‘‰ Find a **common denominator** by multiplying denominators, then add numerators.
ðŸ‘‰ Finally, simplify by dividing numerator and denominator by their **GCD**.

**Logic:** Convert fractions to common denominator by multiplying denominators, then add numerators. Reduce by finding GCD through trial division.

```java
public class AddFractionsBruteForce {
    // Function to find GCD
    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    // Brute force addition
    public static String addFractions(int a, int b, int c, int d) {
        // Step 1: Common denominator (cross multiplication)
        int numerator = a * d + b * c;
        int denominator = b * d;

        // Step 2: Reduce fraction
        int g = gcd(numerator, denominator);
        numerator /= g;
        denominator /= g;

        return numerator + "/" + denominator;
    }

    public static void main(String[] args) {
        System.out.println(addFractions(1, 2, 3, 4)); // 5/4
        System.out.println(addFractions(1, 3, 1, 6)); // 1/2
    }
}
```

### âœ… Complexity:

* **Time:** O(log(min(numerator, denominator))) (due to GCD)
* **Space:** O(1)

---

## ðŸ”¹ Optimized Approach

ðŸ‘‰ Instead of multiplying denominators (which may cause overflow), find **LCM** of denominators using **GCD**.
ðŸ‘‰ Then convert fractions to same denominator and add.

```java
public class AddFractionsOptimized {
    // GCD function
    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    // LCM function
    private static int lcm(int a, int b) {
        return (a * b) / gcd(a, b);
    }

    // Optimized addition
    public static String addFractions(int a, int b, int c, int d) {
        // Step 1: Find LCM of denominators
        int lcmDen = lcm(b, d);

        // Step 2: Adjust numerators
        int numerator = a * (lcmDen / b) + c * (lcmDen / d);

        // Step 3: Simplify result
        int g = gcd(numerator, lcmDen);
        numerator /= g;
        lcmDen /= g;

        return numerator + "/" + lcmDen;
    }

    public static void main(String[] args) {
        System.out.println(addFractions(1, 2, 3, 4)); // 5/4
        System.out.println(addFractions(1, 3, 1, 6)); // 1/2
    }
}
```

### âœ… Complexity:

* **Time:** O(log(min(b, d))) (for GCD + LCM + simplification)
* **Space:** O(1)
* **Advantage:** Avoids very large denominators (better for big numbers).

---

âš¡ In summary:

* **Brute Force:** Cross multiplication (easy but may overflow for large numbers).
* **Optimized:** Use **LCM** of denominators (better for handling larger inputs).

---





### Comparison Table
| Approach | Time Complexity | Space Complexity | Notes / Key Focus |
|----------|-----------------|------------------|-------------------|
| Brute-force | O(min(a,b)) | O(1) | Trial division for GCD, simple multiplication for common denominator |
| Optimized | O(log(min(a,b))) | O(1) | Euclidean algorithm for GCD, LCM for smaller common denominator |

### Edge Cases / Test Cases
- One or both fractions are zero
- Denominators are zero (invalid input)
- Negative fractions
- Result is a whole number (denominator becomes 1)
- Fractions already in simplest form
- Large numerators/denominators that might overflow
- Fractions with same denominator
- Result fraction needs significant reduction

---

## Problem 2: Check if a Number is a Power of Another Number

### Problem Statement
Given two positive integers x and y, determine if x is a power of y. That is, check if there exists a non-negative integer n such that y^n = x. For example, 8 is a power of 2 (2^3 = 8), but 10 is not a power of 3.

Absolutely! Iâ€™ll add **time and space complexity comments directly inside both code approaches** so you can see them while reading the code.

---

## **1ï¸âƒ£ Brute-Force Approach (with comments)**

```java
public class PowerCheck {
    public static boolean isPowerOf(int n, int x) {
        // Edge cases
        if (n == 1) return true;       // 1 is power of any x
        if (x == 1) return n == 1;     // Only 1^k = 1
        if (n < 1 || x < 1) return false;

        // Loop divides n by x repeatedly
        while (n % x == 0) {
            n /= x;
        }

        return n == 1;
    }

    public static void main(String[] args) {
        System.out.println(isPowerOf(1, 5));    // true
        System.out.println(isPowerOf(1, 1));    // true
        System.out.println(isPowerOf(8, 2));    // true
        System.out.println(isPowerOf(12, 2));   // false
        System.out.println(isPowerOf(0, 2));    // false
        System.out.println(isPowerOf(2, 1));    // false
    }
}

/*
Time Complexity: O(log_x n)
- Because n is divided by x in each iteration
- Loop runs approximately log_x(n) times

Space Complexity: O(1)
- Only a few variables used (n, loop counter)
*/
```

---

## **2ï¸âƒ£ Logarithm Approach (with comments)**

```java
public class PowerCheckOptimized {
    public static boolean isPowerOf(int n, int x) {
        // Edge cases
        if (n == 1) return true;       // 1 is power of any x
        if (x == 1) return n == 1;     // Only 1^k = 1
        if (n < 1 || x < 1) return false;

        // Using logarithms to check
        double logResult = Math.log(n) / Math.log(x);

        // Check if logResult is an integer (within floating point tolerance)
        return Math.abs(logResult - Math.round(logResult)) < 1e-10;
    }

    public static void main(String[] args) {
        System.out.println(isPowerOf(1, 5));    // true
        System.out.println(isPowerOf(1, 1));    // true
        System.out.println(isPowerOf(8, 2));    // true
        System.out.println(isPowerOf(12, 2));   // false
        System.out.println(isPowerOf(0, 2));    // false
        System.out.println(isPowerOf(2, 1));    // false
    }
}

/*
Time Complexity: O(1)
- Only a few math operations (log, division, subtraction, rounding)
- Constant time regardless of n or x

Space Complexity: O(1)
- Only a few variables used (logResult)
*/
```

---

### Comparison Table
| Approach | Time Complexity | Space Complexity | Notes / Key Focus |
|----------|-----------------|------------------|-------------------|
| Brute-force | O(log_y(x)) | O(1) | Iterative multiplication until target reached |
| Optimized | O(log n) | O(1) | Logarithms + fast exponentiation for verification |

### Edge Cases / Test Cases
- x = 1 (always a power of any positive y)
- y = 1 (only x = 1 is valid)
- x = y (y^1 = y)
- x < y but x is still a power (like 1/4 for fractional powers)
- Large values that might cause overflow
- x and y are equal
- x is much larger than y
- Prime numbers (only powers are 1 and the number itself)

---

## Problem 3: Find if a Given Number is Armstrong Number

### Problem Statement
An Armstrong number (also known as narcissistic number) is a number that is equal to the sum of its digits raised to the power of the number of digits. For example, 153 is an Armstrong number because 153 = 1^3 + 5^3 + 3^3 (3 digits, so power is 3). Similarly, 9474 = 9^4 + 4^4 + 7^4 + 4^4.

### Brute-force Approach
**Logic:** Convert number to string to count digits and extract them, then calculate sum of powers using repeated multiplication.

```java
public class ArmstrongBruteForce {
    // Time Complexity: O(dÂ²), Space Complexity: O(d) where d is number of digits
    public static boolean isArmstrong(int n) {
        if (n < 0) {
            return false; // Negative numbers are not Armstrong
        }
        
        if (n == 0) {
            return true; // 0 is considered Armstrong
        }
        
        // Convert to string to easily access digits
        String numStr = String.valueOf(n);
        int numDigits = numStr.length(); // Count digits
        
        int sum = 0;
        
        // Process each digit
        for (int i = 0; i < numStr.length(); i++) {
            int digit = numStr.charAt(i) - '0'; // Extract digit
            
            // Calculate digit^numDigits using repeated multiplication
            int power = 1;
            for (int j = 0; j < numDigits; j++) { // O(d) for each digit
                power *= digit;
            }
            
            sum += power; // Add to total sum
            
            // Early termination if sum exceeds original number
            if (sum > n) {
                return false;
            }
        }
        
        return sum == n;
    }
}
```

### Optimized Approach
**Logic:** Use mathematical operations to extract digits without string conversion and use efficient exponentiation for power calculation.

```java
public class ArmstrongOptimized {
    // Time Complexity: O(d log d), Space Complexity: O(1)
    public static boolean isArmstrong(int n) {
        if (n < 0) {
            return false; // Negative numbers are not Armstrong
        }
        
        if (n == 0) {
            return true; // 0 is considered Armstrong
        }
        
        int original = n;
        int numDigits = countDigits(n); // Count digits efficiently
        int sum = 0;
        
        // Extract digits using modulo and division
        while (n > 0) {
            int digit = n % 10; // Get last digit
            sum += fastPower(digit, numDigits); // Use fast exponentiation
            n /= 10; // Remove last digit
            
            // Early termination optimization
            if (sum > original) {
                return false;
            }
        }
        
        return sum == original;
    }
    
    // Count digits without string conversion - O(log n)
    private static int countDigits(int n) {
        if (n == 0) return 1;
        
        int count = 0;
        while (n > 0) {
            count++;
            n /= 10;
        }
        return count;
    }
    
    // Fast exponentiation - O(log exp)
    private static int fastPower(int base, int exp) {
        if (exp == 0) return 1;
        if (exp == 1) return base;
        
        int result = 1;
        
        while (exp > 0) {
            if (exp % 2 == 1) { // If exponent is odd
                result *= base;
            }
            base *= base; // Square the base
            exp /= 2;     // Halve the exponent
        }
        
        return result;
    }
}
```

```java
// If you want to handle negative exponents, we must use double return type
private static double fastPower(double base, int exp) {
    if (exp == 0) return 1;
    if (exp < 0) {
        base = 1 / base;   // reciprocal
        exp = -exp;        // make exponent positive
    }
    
    double result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {   // if odd
            result *= base;
        }
        base *= base;   // square the base
        exp /= 2;       // halve the exponent
    }
    return result;
}
```

### Comparison Table
| Approach | Time Complexity | Space Complexity | Notes / Key Focus |
|----------|-----------------|------------------|-------------------|
| Brute-force | O(dÂ²) | O(d) | String conversion, repeated multiplication |
| Optimized | O(d log d) | O(1) | Mathematical digit extraction, fast exponentiation |

### Edge Cases / Test Cases
- Single digit numbers (0-9, all are Armstrong)
- Three digit Armstrong numbers (153, 371, 407)
- Four digit Armstrong numbers (1634, 8208, 9474)
- Large numbers that might cause integer overflow
- Zero (special case)
- Negative numbers (not Armstrong by definition)
- Numbers with repeated digits
- Very large Armstrong numbers

---

## Problem 4: Check if a Number is Divisible by 3 Using All Digits

### Problem Statement
Given a positive integer, determine if it's possible to rearrange its digits to form a number that is divisible by 3. This is equivalent to checking if the sum of all digits is divisible by 3, based on the divisibility rule for 3.

### Brute-force Approach
**Logic:** Generate all possible permutations of the digits and check if any permutation is divisible by 3.

```java
import java.util.ArrayList;
import java.util.List;

public class DivisibleBy3BruteForce {
    // Time Complexity: O(d! Ã— d), Space Complexity: O(d!)
    public static boolean canFormDivisibleBy3(int n) {
        if (n < 0) {
            return false; // Handle negative numbers
        }
        
        // Extract digits into array
        String numStr = String.valueOf(n);
        int[] digits = new int[numStr.length()];
        
        for (int i = 0; i < numStr.length(); i++) {
            digits[i] = numStr.charAt(i) - '0';
        }
        
        // Generate all permutations
        List<List<Integer>> permutations = new ArrayList<List<Integer>>();
        List<Integer> digitList = new ArrayList<Integer>();
        for (int digit : digits) {
            digitList.add(digit);
        }
        
        generatePermutations(digitList, 0, permutations);
        
        // Check each permutation for divisibility by 3
        for (List<Integer> perm : permutations) {
            int number = 0;
            
            // Convert permutation to number
            for (int digit : perm) { // O(d) for each permutation
                number = number * 10 + digit;
            }
            
            if (number % 3 == 0) { // Check divisibility
                return true;
            }
        }
        
        return false;
    }
    
    // Generate all permutations recursively - O(d!)
    private static void generatePermutations(List<Integer> digits, int start, 
                                           List<List<Integer>> result) {
        if (start == digits.size()) {
            result.add(new ArrayList<Integer>(digits));
            return;
        }
        
        for (int i = start; i < digits.size(); i++) {
            // Swap elements
            Integer temp = digits.get(start);
            digits.set(start, digits.get(i));
            digits.set(i, temp);
            
            generatePermutations(digits, start + 1, result);
            
            // Backtrack
            temp = digits.get(start);
            digits.set(start, digits.get(i));
            digits.set(i, temp);
        }
    }
}
```

### Optimized Approach
**Logic:** Use the divisibility rule for 3: a number is divisible by 3 if and only if the sum of its digits is divisible by 3.

```java
public class DivisibleBy3Optimized {
    // Time Complexity: O(d), Space Complexity: O(1)
    public static boolean canFormDivisibleBy3(int n) {
        if (n < 0) {
            return false; // Handle negative numbers
        }
        
        int digitSum = 0;
        
        // Calculate sum of all digits
        while (n > 0) {
            digitSum += n % 10; // Add last digit to sum
            n /= 10;            // Remove last digit
        }
        
        // Check if sum is divisible by 3
        return digitSum % 3 == 0;
    }
    
    // Alternative implementation using string (same complexity)
    public static boolean canFormDivisibleBy3Alternative(int n) {
        if (n < 0) {
            return false;
        }
        
        String numStr = String.valueOf(n);
        int sum = 0;
        
        for (int i = 0; i < numStr.length(); i++) { // O(d)
            sum += numStr.charAt(i) - '0'; // Add each digit
        }
        
        return sum % 3 == 0;
    }
}
```

### Comparison Table
| Approach | Time Complexity | Space Complexity | Notes / Key Focus |
|----------|-----------------|------------------|-------------------|
| Brute-force | O(d! Ã— d) | O(d!) | Generates all permutations unnecessarily |
| Optimized | O(d) | O(1) | Uses mathematical divisibility rule |

### Edge Cases / Test Cases
- Single digit numbers (0-9)
- Numbers with all identical digits
- Zero (special case)
- Numbers where sum is exactly divisible by 3
- Numbers where sum leaves remainder 1 or 2 when divided by 3
- Large numbers with many digits
- Numbers with digits that sum to multiples of 3
- Numbers containing zero digits

---

## Problem 5: Count Fibonacci Numbers in Given Range

### Problem Statement
Given a range [low, high], count how many Fibonacci numbers exist within this range (inclusive). Fibonacci sequence starts with 0, 1, and each subsequent number is the sum of the two preceding numbers: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

### Brute-force Approach
**Logic:** Generate Fibonacci numbers one by one and count how many fall within the given range.

```java
public class FibonacciCountBruteForce {
    // Time Complexity: O(k), Space Complexity: O(1) where k is index of largest Fib <= high
    public static int countFibonacci(int low, int high) {
        if (low > high || high < 0) {
            return 0; // Invalid range
        }
        
        int count = 0;
        int a = 0; // First Fibonacci number
        int b = 1; // Second Fibonacci number
        
        // Check if first two Fibonacci numbers are in range
        if (a >= low && a <= high) {
            count++; // Count F(0) = 0
        }
        
        if (b >= low && b <= high && b != a) {
            count++; // Count F(1) = 1 (avoid double counting if low=0, high=1)
        }
        
        // Generate subsequent Fibonacci numbers
        while (true) {
            int next = a + b; // Calculate next Fibonacci number
            
            if (next > high) {
                break; // Exceeded upper bound
            }
            
            if (next >= low) {
                count++; // Number is in range
            }
            
            // Update for next iteration
            a = b;
            b = next;
            
            // Prevent overflow
            if (next > Integer.MAX_VALUE - b) {
                break;
            }
        }
        
        return count;
    }
}
```

### Optimized Approach
**Logic:** Use binary search approach or mathematical properties to quickly find the range of Fibonacci indices, then count directly.

```java
public class FibonacciCountOptimized {

    // Function to count Fibonacci numbers in range [low, high]
    public static int countFibsInRange(long low, long high) {
        if (low > high) return 0;

        int count = 0;
        long a = 0, b = 1;

        // Generate Fibonacci numbers until we pass `high`
        while (a <= high) {
            if (a >= low) {
                count++;
            }
            long next = a + b;
            a = b;
            b = next;
        }

        return count;
    }

    // Driver
    public static void main(String[] args) {
        long low = 10, high = 1000;
        int result = countFibsInRange(low, high);
        System.out.println("Count of Fibonacci numbers between " + low + " and " + high + " = " + result);
    }
}


///appraocj-n

public class FibonacciCountOptimized {
    // Time Complexity: O(k), Space Complexity: O(k) where k is number of Fib numbers <= high
    public static int countFibonacci(int low, int high) {
        if (low > high || high < 0) {
            return 0; // Invalid range
        }
        
        // Pre-generate Fibonacci numbers up to the limit
        List<Long> fibNumbers = generateFibonacci(high);
        
        int count = 0;
        
        // Count numbers in range using binary search bounds
        for (Long fib : fibNumbers) {
            if (fib >= low && fib <= high) {
                count++;
            } else if (fib > high) {
                break; // No more numbers in range
            }
        }
        
        return count;
    }
    
    // Generate Fibonacci numbers up to limit - O(k)
    private static List<Long> generateFibonacci(int limit) {
        List<Long> fibList = new ArrayList<Long>();
        
        if (limit < 0) return fibList;
        
        long a = 0, b = 1;
        fibList.add(a); // Add F(0) = 0
        
        if (limit >= 1) {
            fibList.add(b); // Add F(1) = 1
        }
        
        while (true) {
            long next = a + b;
            
            if (next > limit) {
                break;
            }
            
            fibList.add(next);
            a = b;
            b = next;
            
            // Prevent overflow
            if (next > Long.MAX_VALUE - b) {
                break;
            }
        }
        
        return fibList;
    }
    
    // Alternative: Using ArrayList without generics for compatibility
    private static ArrayList generateFibonacciCompatible(int limit) {
        ArrayList fibList = new ArrayList();
        
        if (limit < 0) return fibList;
        
        long a = 0, b = 1;
        fibList.add(new Long(a));
        
        if (limit >= 1) {
            fibList.add(new Long(b));
        }
        
        while (true) {
            long next = a + b;
            
            if (next > limit) {
                break;
            }
            
            fibList.add(new Long(next));
            a = b;
            b = next;
        }
        
        return fibList;
    }
}
```

### Comparison Table
| Approach | Time Complexity | Space Complexity | Notes / Key Focus |
|----------|-----------------|------------------|-------------------|
| Brute-force | O(k) | O(1) | Generate and count on-the-fly |
| Optimized | O(k) | O(k) | Pre-generate for potential reuse |

### Edge Cases / Test Cases
- Range where low > high (invalid)
- Range containing no Fibonacci numbers
- Range containing only one Fibonacci number
- Range [0, 1] containing first two Fibonacci numbers
- Very large ranges that might cause integer overflow
- Range starting from 0
- Range where low = high and equals a Fibonacci number
- Negative ranges (no Fibonacci numbers are negative)
- Large Fibonacci numbers approaching integer limits

---

## Problem 6: Program to Check Strength of Password

### Problem Statement
Determine the strength of a password based on various criteria such as length, presence of uppercase/lowercase letters, digits, special characters, and absence of common patterns. Classify the password as Weak, Moderate, Strong, or Very Strong based on how many criteria it meets.

### Brute-force Approach
**Logic:** Check each character individually for all criteria using nested loops and multiple passes through the password string.

```java
public class PasswordStrengthBruteForce {
    // Time Complexity: O(n Ã— m), Space Complexity: O(1)
    // where n is password length, m is number of criteria checks
    public static String checkPasswordStrength(String password) {
        if (password == null) {
            return "Invalid"; // Null password
        }
        
        int score = 0;
        int length = password.length();
        
        // Check minimum length - O(1)
        if (length >= 8) {
            score++;
        }
        
        // Check for lowercase letters - O(n)
        boolean hasLowercase = false;
        for (int i = 0; i < length; i++) {
            char c = password.charAt(i);
            if (c >= 'a' && c <= 'z') {
                hasLowercase = true;
                break;
            }
        }
        if (hasLowercase) score++;
        
        // Check for uppercase letters - O(n)
        boolean hasUppercase = false;
        for (int i = 0; i < length; i++) {
            char c = password.charAt(i);
            if (c >= 'A' && c <= 'Z') {
                hasUppercase = true;
                break;
            }
        }
        if (hasUppercase) score++;
        
        // Check for digits - O(n)
        boolean hasDigit = false;
        for (int i = 0; i < length; i++) {
            char c = password.charAt(i);
            if (c >= '0' && c <= '9') {
                hasDigit = true;
                break;
            }
        }
        if (hasDigit) score++;
        
        // Check for special characters - O(n)
        boolean hasSpecial = false;
        String specialChars = "!@#$%^&*()_+-=[]{}|;:,.<>?";
        for (int i = 0; i < length; i++) {
            char c = password.charAt(i);
            for (int j = 0; j < specialChars.length(); j++) { // O(m) for each char
                if (c == specialChars.charAt(j)) {
                    hasSpecial = true;
                    break;
                }
            }
            if (hasSpecial) break;
        }
        if (hasSpecial) score++;
        
        // Check for no repeated sequences - O(nÂ²)
        boolean hasRepeatedSequence = false;
        for (int i = 0; i < length - 2; i++) {
            for (int j = i + 3; j <= length; j++) {
                String substring = password.substring(i, i + 3);
                for (int k = j - 2; k < length - 2; k++) {
                    if (password.substring(k, k + 3).equals(substring)) {
                        hasRepeatedSequence = true;
                        break;
                    }
                }
                if (hasRepeatedSequence) break;
            }
            if (hasRepeatedSequence) break;
        }
        if (!hasRepeatedSequence) score++;
        
        // Determine strength based on score
        if (score <= 2) return "Weak";
        if (score <= 3) return "Moderate";
        if (score <= 4) return "Strong";
        return "Very Strong";
    }
}
```

### Optimized Approach
**Logic:** Single pass through the password to check multiple criteria simultaneously, using bit flags and efficient character classification.

```java
import java.util.HashSet;
import java.util.Set;

public class PasswordStrengthOptimized {
    // Time Complexity: O(n), Space Complexity: O(n)
    public static String checkPasswordStrength(String password) {
        if (password == null) {
            return "Invalid";
        }
        
        int score = 0;
        int length = password.length();
        
        // Check length criterion
        if (length >= 8) score++;
        if (length >= 12) score++; // Bonus for very long passwords
        
        // Use flags to track criteria in single pass
        boolean hasLower = false, hasUpper = false;
        boolean hasDigit = false, hasSpecial = false;
        
        // Use set to detect repeated characters efficiently
        Set charCounts = new HashSet();
        int repeatedChars = 0;
        
        // Single pass through password - O(n)
        for (int i = 0; i < length; i++) {
            char c = password.charAt(i);
            
            // Count character frequency
            Character charObj = new Character(c);
            if (charCounts.contains(charObj)) {
                repeatedChars++;
            } else {
                charCounts.add(charObj);
            }
            
            // Check character categories
            if (c >= 'a' && c <= 'z') {
                hasLower = true;
            } else if (c >= 'A' && c <= 'Z') {
                hasUpper = true;
            } else if (c >= '0' && c <= '9') {
                hasDigit = true;
            } else if (isSpecialChar(c)) {
                hasSpecial = true;
            }
        }
        
        // Add scores for character variety
        if (hasLower) score++;
        if (hasUpper) score++;
        if (hasDigit) score++;
        if (hasSpecial) score++;
        
        // Penalty for too many repeated characters
        if (repeatedChars > length / 2) {
            score--; // Too many repeated characters
        }
        
        // Check for common weak patterns
        if (hasCommonPattern(password)) {
            score--; // Penalty for common patterns
        }
        
        // Bonus for character diversity
        double diversity = (double) charCounts.size() / length;
        if (diversity > 0.7) {
            score++; // Good character diversity
        }
        
        // Ensure score doesn't go below 0
        score = Math.max(0, score);
        
        // Determine strength based on score
        if (score <= 2) return "Weak";
        if (score <= 4) return "Moderate";
        if (score <= 6) return "Strong";
        return "Very Strong";
    }
    
    // Check if character is special - O(1)
    private static boolean isSpecialChar(char c) {
        return (c >= 33 && c <= 47) || // !"#$%&'()*+,-./
               (c >= 58 && c <= 64) || // :;<=>?@
               (c >= 91 && c <= 96) || // [\]^_`
               (c >= 123 && c <= 126); // {|}~
    }
    
    // Check for common weak patterns - O(n)
    private static boolean hasCommonPattern(String password) {
        String lower = password.toLowerCase();
        
        // Check for common sequences
        String[] commonPatterns = {
            "123", "abc", "qwerty", "password", "admin",
            "user", "login", "welcome", "12345", "abcde"
        };
        
        for (int i = 0; i < commonPatterns.length; i++) {
            if (lower.indexOf(commonPatterns[i]) != -1) {
                return true; // Found common pattern
            }
        }
        
        // Check for repeated characters (more than 2 consecutive)
        for (int i = 0; i < password.length() - 2; i++) {
            if (password.charAt(i) == password.charAt(i + 1) && 
                password.charAt(i + 1) == password.charAt(i + 2)) {
                return true; // Three consecutive same characters
            }
        }
        
        // Check for simple ascending/descending sequences
        for (int i = 0; i < password.length() - 2; i++) {
            char c1 = password.charAt(i);
            char c2 = password.charAt(i + 1);
            char c3 = password.charAt(i + 2);
            
            if ((c1 + 1 == c2 && c2 + 1 == c3) || // Ascending sequence
                (c1 - 1 == c2 && c2 - 1 == c3)) { // Descending sequence
                return true;
            }
        }
        
        return false;
    }
}
```

### Comparison Table
| Approach | Time Complexity | Space Complexity | Notes / Key Focus |
|----------|-----------------|------------------|-------------------|
| Brute-force | O(n Ã— m) | O(1) | Multiple passes, nested loops for pattern checking |
| Optimized | O(n) | O(n) | Single pass with efficient pattern detection |

### Edge Cases / Test Cases
- Empty password or null input
- Very short passwords (< 4 characters)
- Passwords with only one type of character
- Passwords with all character types but common patterns
- Very long passwords with good diversity
- Passwords with special characters only
- Passwords with repeated sequences
- Common weak passwords ("password123", "admin", etc.)
- Passwords with keyboard patterns ("qwerty", "asdf")
- Mixed case passwords with numbers and symbols