Here’s a **comprehensive guide** for the problem **“First Unique Character of a String”** in the structured format you requested:

---

## 1. Problem Statement & Example

**Problem:**
Given a string `s`, find the **first non-repeating character** in it and return its **index**. If it does not exist, return `-1`.

**Example 1:**

```
Input: s = "leetcode"
Output: 0
Explanation: 'l' is the first unique character.
```

**Example 2:**

```
Input: s = "loveleetcode"
Output: 2
Explanation: 'v' is the first unique character.
```

**Example 3:**

```
Input: s = "aabb"
Output: -1
Explanation: No unique character exists.
```

---

## 2. Approaches

### **Approach 1: Brute Force**

**Logic:**

* For each character, check if it appears only once by scanning the entire string.
* Return the index of the first character that appears only once.

**Time Complexity:** O(n²)
**Space Complexity:** O(1)
**Use When:** Input is very small or constraints are loose.

---

### **Approach 2: HashMap / Frequency Count**

**Logic:**

* Use a `HashMap<Character, Integer>` to count frequency of each character.
* Traverse the string again and return the first character with frequency = 1.

**Time Complexity:** O(n)
**Space Complexity:** O(n)
**Use When:** Standard optimized solution for general strings.

---

### **Approach 3: Array (for lowercase letters)**

**Logic:**

* Use an array of size 26 to store frequency of lowercase letters (`'a' - 'z'`).
* Traverse the string and check first character with count 1.

**Time Complexity:** O(n)
**Space Complexity:** O(1) (26 letters → constant)
**Use When:** Input is limited to lowercase English letters.

---

### **Approach 4: LinkedHashMap (Preserve Insertion Order)**

**Logic:**

* Use `LinkedHashMap` to store frequencies while maintaining insertion order.
* Iterate over `LinkedHashMap` to get first unique character.

**Time Complexity:** O(n)
**Space Complexity:** O(n)
**Use When:** Need to preserve order and frequencies simultaneously.

---

### **Approach 5: Java 8 Streams**

**Logic:**

* Use streams to count characters (`Collectors.groupingBy`) and filter to get first unique.

**Time Complexity:** O(n)
**Space Complexity:** O(n)
**Use When:** Prefer functional/modern Java style.

---

## 3. Comparison Table

| Approach           | Time Complexity | Space Complexity | Pros                           | Cons                     |
| ------------------ | --------------- | ---------------- | ------------------------------ | ------------------------ |
| Brute Force        | O(n²)           | O(1)             | Simple to implement            | Slow for large strings   |
| HashMap            | O(n)            | O(n)             | Optimized, works for any chars | Extra space for map      |
| Array (26 letters) | O(n)            | O(1)             | Fast and minimal memory        | Only works for lowercase |
| LinkedHashMap      | O(n)            | O(n)             | Maintains order, general chars | Slightly higher overhead |
| Java 8 Streams     | O(n)            | O(n)             | Modern, concise code           | Can be slower, verbose   |

---

## 4. Code (Java)

### **Optimized HashMap Approach**

```java
import java.util.*;

public class FirstUniqueChar {
    public static int firstUniqChar(String s) {
        if (s == null || s.isEmpty()) return -1;

        Map<Character, Integer> freqMap = new HashMap<>();

        // Count frequency of each character
        for (char c : s.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }

        // Find first unique character
        for (int i = 0; i < s.length(); i++) {
            if (freqMap.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1; // No unique character found
    }

    public static void main(String[] args) {
        System.out.println(firstUniqChar("leetcode"));      // 0
        System.out.println(firstUniqChar("loveleetcode"));  // 2
        System.out.println(firstUniqChar("aabb"));          // -1
    }
}
```

---

### **Array-Based Approach (lowercase letters)**

```java
public static int firstUniqCharArray(String s) {
    int[] count = new int[26];
    for (char c : s.toCharArray()) {
        count[c - 'a']++;
    }
    for (int i = 0; i < s.length(); i++) {
        if (count[s.charAt(i) - 'a'] == 1) return i;
    }
    return -1;
}
```

---

### **Java 8 Streams Approach**

```java
import java.util.*;
import java.util.stream.*;

public static int firstUniqCharStream(String s) {
    Map<Character, Long> freqMap = s.chars()
                                   .mapToObj(c -> (char)c)
                                   .collect(Collectors.groupingBy(c -> c, LinkedHashMap::new, Collectors.counting()));

    return IntStream.range(0, s.length())
                    .filter(i -> freqMap.get(s.charAt(i)) == 1)
                    .findFirst()
                    .orElse(-1);
}
```

---

## 5. Test Cases & Edge Cases

| Test Case        | Expected Output | Notes                                |
| ---------------- | --------------- | ------------------------------------ |
| `"leetcode"`     | 0               | First character is unique            |
| `"loveleetcode"` | 2               | First unique is in middle            |
| `"aabb"`         | -1              | No unique character                  |
| `""`             | -1              | Empty string                         |
| `"z"`            | 0               | Single character                     |
| `"aaabccc"`      | 3               | Only one unique in middle            |
| `"aaaa"`         | -1              | All repeated                         |
| `"abcabcde"`     | 6               | Multiple unique but first at index 6 |

---

## 6. Pitfalls & Best Practices

* **Common Mistakes:**

  * Returning the first character instead of its index.
  * Using string concatenation inside loops (inefficient).
  * Not handling empty/null strings.
  * Confusing first non-repeating with first repeating character.

* **Best Practices:**

  * Use frequency counting for O(n) solutions.
  * Use array instead of hashmap if input is constrained (like lowercase).
  * Avoid nested loops for large input.
  * Consider immutability and readability in Java 8 Streams.

---

## 7. Optional: JUnit Test Class (for Optimized Approach)

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class FirstUniqueCharTest {

    @Test
    void testFirstUniqChar() {
        assertEquals(0, FirstUniqueChar.firstUniqChar("leetcode"));
        assertEquals(2, FirstUniqueChar.firstUniqChar("loveleetcode"));
        assertEquals(-1, FirstUniqueChar.firstUniqChar("aabb"));
        assertEquals(-1, FirstUniqueChar.firstUniqChar(""));
        assertEquals(0, FirstUniqueChar.firstUniqChar("z"));
        assertEquals(3, FirstUniqueChar.firstUniqChar("aaabccc"));
        assertEquals(6, FirstUniqueChar.firstUniqChar("abcabcde"));
    }
}
```

---

## 8. Related / Follow-Up Questions

* Find the **first unique character recursively**.
* Find **all unique characters** instead of just the first.
* Handle **Unicode characters** instead of just lowercase letters.
* Find first **unique word** in a sentence.
* Optimize for **streaming input** (large text files).
* Return the **character itself** instead of the index.

---

If you want, I can also **draw a visual step-by-step dry run** for `"loveleetcode"` showing how the frequency map is built and how the first unique is found—it makes understanding much easier.

Do you want me to do that next?
