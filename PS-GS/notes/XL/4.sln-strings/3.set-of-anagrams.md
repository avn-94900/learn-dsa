Sure! Let’s break down **“Set of anagrams of a list of words”** step by step in the structured way you requested. I’ll cover all aspects comprehensively.

---

# **Problem Statement & Example**

**Problem Statement:**
Given a list of words, group them into sets of anagrams. Words that are anagrams of each other should be placed in the same group. Return a collection of these sets.

**Definition:**
Two words are anagrams if they contain the same characters in the same frequency, e.g., `"listen"` and `"silent"`.

**Input/Output Example:**

```text
Input: ["eat", "tea", "tan", "ate", "nat", "bat"]
Output: [["eat","tea","ate"], ["tan","nat"], ["bat"]]
```

**Notes:**

* Order of groups or order within groups does not matter.
* Each group must contain at least one word.

---

# **Approaches**

### **1. Brute Force (Compare Each Pair)**

**Logic:**

* For each word, compare with all other words to check if they are anagrams.
* Use a frequency counter or sort characters for comparison.

**Time Complexity:**

* Sorting each word: $O(k \log k)$, comparing each pair: $O(n^2)$
* Total: $O(n^2 k \log k)$, where $n$ = number of words, $k$ = length of the word.

**Space Complexity:**

* $O(nk)$ for storing output groups.

**When to use:**

* Only for very small input sets. Inefficient for large lists.

---

### **2. Optimized using Sorted Word as Key**

**Logic:**

* Sort the characters of each word → sorted string becomes the key.
* Use a `HashMap<String, List<String>>` to group words by this key.

**Example:**

```
"eat" -> "aet"
"tea" -> "aet"
"tan" -> "ant"
```

**Time Complexity:**

* Sorting each word: $O(k \log k)$
* Inserting in map: $O(n)$
* Total: $O(n k \log k)$

**Space Complexity:**

* $O(nk)$ for HashMap and result.

**When to use:**

* Best approach for moderate word lengths and input sizes.

---

### **3. Optimized using Character Frequency as Key**

**Logic:**

* Count frequency of each character (26 lowercase letters) → encode into a string like `"1_0_0_1_..."`
* Use this as key in a HashMap.

**Time Complexity:**

* Counting frequencies: $O(k)$ per word
* Total: $O(n k)$ → faster than sorting approach for long words

**Space Complexity:**

* $O(nk)$ for map and result.

**When to use:**

* When words are very long; sorting may be slower than frequency count.

---

### **4. Recursive / Backtracking Approach**

* Rarely used for grouping anagrams. Could generate all permutations of words and check matches → impractical due to factorial complexity.

---

# **Comparison Table**

| Approach                   | Time Complexity | Space Complexity | Pros                          | Cons                          |
| -------------------------- | --------------- | ---------------- | ----------------------------- | ----------------------------- |
| Brute Force                | O(n² k log k)   | O(nk)            | Simple to implement           | Very slow for large n         |
| Sorted Word as Key         | O(n k log k)    | O(nk)            | Efficient, simple             | Sorting cost for long words   |
| Character Frequency as Key | O(n k)          | O(nk)            | Most optimized for long words | Slightly complex key encoding |
| Recursive / Backtracking   | O(n! \* k)      | O(nk)            | Theoretical, educational      | Not practical                 |

---

# **Code (Java)**

### **File 1: BruteForceAnagrams.java**

```java
import java.util.*;

public class BruteForceAnagrams {
    // Check if two words are anagrams
    private static boolean isAnagram(String a, String b) {
        if(a.length() != b.length()) return false;
        char[] c1 = a.toCharArray();
        char[] c2 = b.toCharArray();
        Arrays.sort(c1);
        Arrays.sort(c2);
        return Arrays.equals(c1, c2);
    }

    public static List<List<String>> groupAnagrams(String[] words) {
        List<List<String>> result = new ArrayList<>();
        boolean[] used = new boolean[words.length];

        for(int i=0; i<words.length; i++){
            if(used[i]) continue;
            List<String> group = new ArrayList<>();
            group.add(words[i]);
            used[i] = true;
            for(int j=i+1; j<words.length; j++){
                if(!used[j] && isAnagram(words[i], words[j])){
                    group.add(words[j]);
                    used[j] = true;
                }
            }
            result.add(group);
        }
        return result;
    }

    public static void main(String[] args){
        String[] input = {"eat","tea","tan","ate","nat","bat"};
        System.out.println(groupAnagrams(input));
    }
}
```

---

### **File 2: SortedKeyAnagrams.java**

```java
import java.util.*;

public class SortedKeyAnagrams {
    public static List<List<String>> groupAnagrams(String[] words) {
        Map<String, List<String>> map = new HashMap<>();
        for(String word : words){
            char[] chars = word.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            map.computeIfAbsent(key, k -> new ArrayList<>()).add(word);
        }
        return new ArrayList<>(map.values());
    }

    public static void main(String[] args){
        String[] input = {"eat","tea","tan","ate","nat","bat"};
        System.out.println(groupAnagrams(input));
    }
}
```

---

### **File 3: FrequencyKeyAnagrams.java**

```java
import java.util.*;

public class FrequencyKeyAnagrams {
    public static List<List<String>> groupAnagrams(String[] words) {
        Map<String, List<String>> map = new HashMap<>();
        for(String word : words){
            int[] freq = new int[26];
            for(char c : word.toCharArray()){
                freq[c - 'a']++;
            }
            StringBuilder key = new StringBuilder();
            for(int count : freq){
                key.append(count).append('#'); // unique separator
            }
            map.computeIfAbsent(key.toString(), k -> new ArrayList<>()).add(word);
        }
        return new ArrayList<>(map.values());
    }

    public static void main(String[] args){
        String[] input = {"eat","tea","tan","ate","nat","bat"};
        System.out.println(groupAnagrams(input));
    }
}
```

---

# **Test Cases & Edge Cases**

**Common Cases:**

1. Standard input:
   `["eat","tea","tan","ate","nat","bat"]`
2. Single word:
   `["hello"]`
3. Empty input:
   `[]`
4. All words unique (no anagrams):
   `["cat","dog","bird"]`

**Tricky Cases:**

1. Words with different cases (optional handling):
   `["Eat", "Tea", "ate"]`
2. Words with repeating letters:
   `["aaab","abaa","baaa"]`
3. Very long words.

---

# **Pitfalls & Best Practices**

* **Pitfall 1:** Forgetting to normalize (case-sensitive vs case-insensitive).
* **Pitfall 2:** Using string concatenation in frequency key without separators → collisions.
* **Best Practices:**

  * Use `computeIfAbsent` in Java `HashMap`.
  * Use character frequency encoding for long words to avoid sorting overhead.

---

# **Optional: JUnit Test Class**

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

public class AnagramsTest {
    @Test
    public void testSortedKeyAnagrams() {
        String[] input = {"eat","tea","tan","ate","nat","bat"};
        List<List<String>> output = SortedKeyAnagrams.groupAnagrams(input);
        // Check group count
        assertEquals(3, output.size());
        // Flatten all words
        List<String> allWords = new ArrayList<>();
        for(List<String> group : output) allWords.addAll(group);
        assertTrue(allWords.containsAll(Arrays.asList(input)));
    }

    @Test
    public void testEdgeCases() {
        assertEquals(Collections.emptyList(), SortedKeyAnagrams.groupAnagrams(new String[]{}));
        assertEquals(1, SortedKeyAnagrams.groupAnagrams(new String[]{"hello"}).size());
    }
}
```

---

# **Related / Follow-Up Questions**

1. Return count of anagram groups instead of words.
2. Only return largest anagram group.
3. Input is a stream → build groups incrementally.
4. Extend to unicode / multibyte characters.
5. Optimize for very large dataset using parallel processing.
6. Switch input type: linked list of words instead of array.

---

I can also **draw a step-by-step visualization of how words are grouped by sorted key or frequency key**, which really helps in interviews.

Do you want me to do that next?
