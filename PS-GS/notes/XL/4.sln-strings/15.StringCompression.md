## StringCompression

* Runs in **O(N)** time.
* Uses only a **StringBuilder** (no extra arrays, maps, etc.).
* Starts looping from index `1` while tracking the previous character.
* Appends `count + char` whenever the character changes.

Hereâ€™s the clean implementation:

```java
public class StringCompression {

    public static void main(String[] args) {
        System.out.println(compress("SSSSSTTPPQ")); // 5S2T2P1Q
        System.out.println(compress("AAABCCDDDD")); // 3A1B2C4D
        System.out.println(compress("A"));          // 1A
        System.out.println(compress(""));           // ""
    }

    /**
     * Compresses the string in the form count + character.
     *
     * Time Complexity: O(N)
     * Space Complexity: O(1) extra (ignoring output string)
     */
    public static String compress(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        int count = 1; // track frequency of current character

        // Start from index 1 and compare with previous character
        for (int i = 1; i < input.length(); i++) {
            if (input.charAt(i) == input.charAt(i - 1)) {
                count++;
            } else {
                sb.append(count).append(input.charAt(i - 1));
                count = 1; // reset count for new character
            }
        }

        // Append last character and its count
        sb.append(count).append(input.charAt(input.length() - 1));

        return sb.toString();
    }
}
```

### Output:

```
5S2T2P1Q
3A1B2C4D
1A
""
```
