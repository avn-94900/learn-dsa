Got it ğŸ‘ â€” letâ€™s prepare a **complete solution sheet** for

ğŸ‘‰ **Largest Palindrome in a String â€“ Find the Largest Palindromic Substring**

with **input/output format, 2 explained examples, brute force + optimized code in Java (with clear notes), and complexities**.

---

# ğŸ“ Problem Statement

Given a string `s`, find and return the **longest palindromic substring**.

---

# ğŸ“¥ Input Format

* A single string `s` containing lowercase/uppercase English letters.

# ğŸ“¤ Output Format

* The **longest palindromic substring**.
* If multiple longest palindromes exist, return either (or choose first/last based on logic).

---

# âœ… Example 1

**Input:**

```
babad
```

**Output:**

```
bab
```

(or `"aba"` is also valid, both length 3 palindromes)

**Explanation:**

* Substrings: `"bab"`, `"aba"` are both palindromes of length 3.
* Longest length = 3.

---

# âœ… Example 2

**Input:**

```
cbbd
```

**Output:**

```
bb
```

**Explanation:**

* Palindromes: `"c"`, `"b"`, `"bb"`, `"d"`.
* Longest is `"bb"` of length 2.

---

# ğŸ› ï¸ Approaches

---

## 1ï¸âƒ£ Brute Force Approach

### Logic

* Generate **all substrings**.
* Check each substring if palindrome.
* Keep track of the longest one.

### Java Code (Brute Force)

```java
public class LongestPalindromeBruteForce {

    // Utility method to check if a string portion is palindrome
    private static boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) {
                return false;
            }
        }
        return true;
    }

    // Brute Force method
    public static String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";

        String longest = "";

        // Generate all substrings
        for (int i = 0; i < s.length(); i++) {
            for (int j = i; j < s.length(); j++) {
                // Check if substring s[i..j] is palindrome
                if (isPalindrome(s, i, j)) {
                    if (j - i + 1 > longest.length()) {
                        longest = s.substring(i, j + 1);
                    }
                }
            }
        }
        return longest;
    }

    public static void main(String[] args) {
        System.out.println(longestPalindrome("babad")); // bab or aba
        System.out.println(longestPalindrome("cbbd"));  // bb
    }
}
```

### Complexity (Brute Force)

* **Time:** `O(n^3)` â†’ `O(n^2)` substrings Ã— `O(n)` check.
* **Space:** `O(1)` (ignoring substring storage).

---

## 2ï¸âƒ£ Optimized Approach â€“ Expand Around Center

### Logic

* Every palindrome is centered at:

  * A single character (odd length)
  * Between two characters (even length)
* Expand outward while characters match.
* Keep track of max length.

### Java Code (Optimized)
```java
public class LongestPalindromeOptimized {

    // Expand around center and return palindrome length
    private static int expandFromCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1; // length of palindrome
    }

    // âœ… Get the first occurrence of the longest palindrome
    public static String longestPalindromeFirst(String s) {
        if (s == null || s.length() < 1) return "";

        int start = 0, end = 0;

        for (int i = 0; i < s.length(); i++) {
            int len1 = expandFromCenter(s, i, i);     // Odd length palindrome
            int len2 = expandFromCenter(s, i, i + 1); // Even length palindrome
            int len = Math.max(len1, len2);

            // Update only if strictly greater (keeps the first occurrence)
            if (len > (end - start + 1)) {
                start = i - (len - 1) / 2;
                end   = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public static void main(String[] args) {
        String s = "abadbcaba";

        System.out.println("First occurrence: " + longestPalindromeFirst(s)); // aba [0..2]
        System.out.println("Last occurrence:  " + longestPalindromeLast(s));  // aba [6..8]
    }
}
```
<br/>

```java
    // âœ… Get the last occurrence of the longest palindrome
    public static String longestPalindromeLast(String s) {
        if (s == null || s.length() < 1) return "";

        int start = 0, end = 0;

        for (int i = 0; i < s.length(); i++) {
            int len1 = expandFromCenter(s, i, i);     // Odd length palindrome
            int len2 = expandFromCenter(s, i, i + 1); // Even length palindrome
            int len = Math.max(len1, len2);

            // Update if >= (allows overwriting with same length â†’ last occurrence)
            if (len >= (end - start + 1)) {
                start = i - (len - 1) / 2;
                end   = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }
```
<br/><br/>

```java
public class LongestPalindromeOptimized {

    // Expand around center and return palindrome length
    private static int expandFromCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1; // length of palindrome
    }

    public static String longestPalindrome(String s, boolean preferLast) {
        if (s == null || s.length() < 1) return "";

        int start = 0, end = 0;

        for (int i = 0; i < s.length(); i++) {
            int len1 = expandFromCenter(s, i, i);     // Odd length palindrome
            int len2 = expandFromCenter(s, i, i + 1); // Even length palindrome
            int len = Math.max(len1, len2);

            // ğŸ”‘ Key difference for first vs last occurrence:
            // preferLast = false â†’ first occurrence
            // preferLast = true  â†’ last occurrence
            boolean shouldUpdate = preferLast
                    ? (len > (end - start))     // allows overwriting with same length
                    : (len > (end - start + 1)); // keeps first occurrence

            if (shouldUpdate) {
                start = i - (len - 1) / 2;
                end   = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public static void main(String[] args) {
        String s = "abadbcaba";

        // First occurrence
        System.out.println(longestPalindrome(s, false)); // aba (first one [0..2])

        // Last occurrence
        System.out.println(longestPalindrome(s, true));  // aba (last one [6..8])
    }
}
```

### Complexity (Optimized)

* **Time:** `O(n^2)` â†’ Each expansion worst-case O(n), and there are `2n-1` centers.
* **Space:** `O(1)` â†’ only variables for indices.

---

# ğŸ“Š Comparison Table

| Approach             | Time Complexity | Space Complexity | Notes                                     |
| -------------------- | --------------- | ---------------- | ----------------------------------------- |
| Brute Force          | `O(n^3)`        | `O(1)`           | Simple, but too slow for large inputs.    |
| Expand Around Center | `O(n^2)`        | `O(1)`           | Practical & widely used.                  |
| Manacherâ€™s Algorithm | `O(n)`          | `O(n)`           | Most efficient, but complex to implement. |

---

âœ… With this, you now have:

* **Input/Output format**
* **2 explained examples**
* **Brute force + Optimized Java code with inline notes**
* **Time/Space complexities & comparison**

---

ğŸ‘‰ Do you want me to also add the **Manacherâ€™s Algorithm (O(n))** version here for completeness, or keep it at brute force + optimized only (enough for 95% of interviews)?
