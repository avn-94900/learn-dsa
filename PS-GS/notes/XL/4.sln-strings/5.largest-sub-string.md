Here’s a **comprehensive guide** for the problem **“Largest Substring with Unique Characters”** following the structure you requested.

---

## 1. Problem Statement & Example

**Problem:**
Given a string `s`, find the length (or the substring itself) of the longest substring that contains **all unique characters**.

**Example 1:**
Input: `"abcabcbb"`
Output: `3` (`"abc"`)

**Example 2:**
Input: `"bbbbb"`
Output: `1` (`"b"`)

**Example 3:**
Input: `"pwwkew"`
Output: `3` (`"wke"`)

**Example 4:**
Input: `""` (empty string)
Output: `0`

---

## 2. Approaches

| Approach                           | Logic                                                                                        | Time Complexity | Space Complexity   | When to Use                                          |
| ---------------------------------- | -------------------------------------------------------------------------------------------- | --------------- | ------------------ | ---------------------------------------------------- |
| **Brute Force**                    | Generate all substrings and check if each has all unique characters                          | O(n³)           | O(n) for set       | Small strings; conceptual clarity                    |
| **Sliding Window + Set**           | Use two pointers, expand the window while characters are unique, shrink when duplicate found | O(n)            | O(min(n, charset)) | Most practical for strings of arbitrary length       |
| **Sliding Window + HashMap/Array** | Track index of last occurrence of each character to jump start of window                     | O(n)            | O(min(n, charset)) | Optimized for large inputs                           |
| **Streams/Functional (Java 8+)**   | Transform string to chars, use streams to build unique sequences                             | O(n²)           | O(n)               | Educational/demo purposes; not ideal for performance |

---

### Approach 1: Brute Force

**Logic:**

* For each starting index `i`, try all substrings `s[i:j]`.
* Check if substring has all unique characters (using a set).
* Track the max length.

**Time Complexity:** O(n³) (substring generation + uniqueness check)
**Space Complexity:** O(n) (set to check uniqueness)

---

### Approach 2: Sliding Window + Set

**Logic:**

1. Use two pointers `start` and `end`.
2. Expand `end` while characters are unique (use a `Set`).
3. When a duplicate is found, remove `s[start]` from the set and increment `start`.
4. Update max length whenever a longer substring is found.

**Time Complexity:** O(n) — Each character visited at most twice
**Space Complexity:** O(min(n, charset))

---

### Approach 3: Sliding Window + HashMap

**Logic:**

1. Use a map to store the **last index** of each character.
2. Move `end` forward; if duplicate found inside window, move `start` to `map.get(char)+1`.
3. Update map with current index of character.
4. Update max length.

**Time Complexity:** O(n)
**Space Complexity:** O(min(n, charset))

**Why use this?**

* Avoids repeated removal in set; faster for large inputs.

---

## 3. Comparison Table

| Approach             | Complexity | Pros                        | Cons                               |
| -------------------- | ---------- | --------------------------- | ---------------------------------- |
| Brute Force          | O(n³)      | Simple, intuitive           | Too slow for large strings         |
| Sliding Window + Set | O(n)       | Efficient, simple           | Slight overhead for set operations |
| Sliding Window + Map | O(n)       | Fastest, minimal operations | Slightly more code, requires map   |

---

## 4. Java Code Implementations

### Approach 2: Sliding Window + Set

```java
import java.util.HashSet;
import java.util.Set;

public class LongestUniqueSubstring {

    public static int lengthOfLongestSubstring(String s) {
        int maxLength = 0;
        Set<Character> set = new HashSet<>();
        int start = 0, end = 0;

        while (end < s.length()) {
            char current = s.charAt(end);
            if (!set.contains(current)) {
                set.add(current);
                maxLength = Math.max(maxLength, end - start + 1);
                end++;
            } else {
                set.remove(s.charAt(start));
                start++;
            }
        }
        return maxLength;
    }

    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring("abcabcbb")); // 3
        System.out.println(lengthOfLongestSubstring("bbbbb"));    // 1
        System.out.println(lengthOfLongestSubstring("pwwkew"));   // 3
        System.out.println(lengthOfLongestSubstring(""));         // 0
    }
}
```

### Approach 3: Sliding Window + HashMap (Optimized)

```java
import java.util.HashMap;
import java.util.Map;

public class LongestUniqueSubstringOptimized {

    public static int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int maxLength = 0, start = 0;

        for (int end = 0; end < s.length(); end++) {
            char c = s.charAt(end);
            // If char is already seen inside the current window
            if (map.containsKey(c) && map.get(c) >= start) {
                start = map.get(c) + 1; // move left pointer
            }
            map.put(c, end);
            maxLength = Math.max(maxLength, end - start + 1);
        }
        return maxLength;
    }

    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring("abcabcbb")); // 3
        System.out.println(lengthOfLongestSubstring("bbbbb"));    // 1
        System.out.println(lengthOfLongestSubstring("pwwkew"));   // 3
        System.out.println(lengthOfLongestSubstring(""));         // 0
    }
}
```

---

## 5. Test Cases & Edge Cases

| Input          | Expected Output | Notes                      |
| -------------- | --------------- | -------------------------- |
| `"abcabcbb"`   | 3               | Normal case                |
| `"bbbbb"`      | 1               | All same characters        |
| `"pwwkew"`     | 3               | Non-consecutive duplicates |
| `""`           | 0               | Empty string               |
| `" "`          | 1               | Single space character     |
| `"au"`         | 2               | Short string               |
| `"dvdf"`       | 3               | Overlapping duplicates     |
| `"abcbdeafgh"` | 7               | Larger string              |

---

## 6. Pitfalls & Best Practices

* **Pitfall:** Forgetting to move `start` properly when duplicate character is found.
* **Pitfall:** Using string concatenation inside loops (inefficient).
* **Best Practice:** Use `HashMap` or `Set` for O(1) lookups.
* **Best Practice:** Always handle empty strings and single-character strings.

---

## 7. Optional: JUnit Test Class (Optimized Approach)

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

public class LongestUniqueSubstringTest {

    @Test
    void testCases() {
        assertEquals(3, LongestUniqueSubstringOptimized.lengthOfLongestSubstring("abcabcbb"));
        assertEquals(1, LongestUniqueSubstringOptimized.lengthOfLongestSubstring("bbbbb"));
        assertEquals(3, LongestUniqueSubstringOptimized.lengthOfLongestSubstring("pwwkew"));
        assertEquals(0, LongestUniqueSubstringOptimized.lengthOfLongestSubstring(""));
        assertEquals(2, LongestUniqueSubstringOptimized.lengthOfLongestSubstring("au"));
        assertEquals(3, LongestUniqueSubstringOptimized.lengthOfLongestSubstring("dvdf"));
        assertEquals(7, LongestUniqueSubstringOptimized.lengthOfLongestSubstring("abcbdeafgh"));
    }
}
```

---

## 8. Related / Follow-Up Questions

* Find the **substring itself** (not just length).
* Longest substring with **at most K unique characters**.
* Count **all substrings** with unique characters.
* Variants with **arrays of integers** instead of strings.
* Recursive or parallelized solutions for very long strings.

---

<br/><br/>
<br/>

Perfect! Let’s extend the **optimized sliding window approach** to **return the substring itself** instead of just the length. I’ll explain clearly, provide Java code, and show dry run logic.

---

## Problem Update

**Input:** `"abcabcbb"`
**Output:** `"abc"`

**Input:** `"pwwkew"`
**Output:** `"wke"`

We want the **longest substring with all unique characters**, not just its length.

---

## Approach: Sliding Window + HashMap (Return Substring)

**Logic:**

1. Use a **HashMap** to store the last index of each character.
2. Maintain a **start pointer** for the current window.
3. For each character `c` at index `end`:

   * If `c` exists in map and its last index ≥ `start`, move `start` to `map.get(c) + 1`.
   * Update the last index of `c` in the map.
   * If `(end - start + 1)` > maxLength, update `maxLength` and **record start index of substring**.
4. Return `s.substring(maxStart, maxStart + maxLength)`.

**Time Complexity:** O(n)
**Space Complexity:** O(min(n, charset))

---

## Java Code

```java
import java.util.HashMap;
import java.util.Map;

public class LongestUniqueSubstringActual {

    public static String longestUniqueSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int maxLength = 0;
        int start = 0;       // start of current window
        int maxStart = 0;    // start index of longest substring

        for (int end = 0; end < s.length(); end++) {
            char c = s.charAt(end);

            // if character is in window, move start pointer
            if (map.containsKey(c) && map.get(c) >= start) {
                start = map.get(c) + 1;
            }

            map.put(c, end); // update last index of c

            // update max length and start index of longest substring
            if (end - start + 1 > maxLength) {
                maxLength = end - start + 1;
                maxStart = start;
            }
        }

        return s.substring(maxStart, maxStart + maxLength);
    }

    public static void main(String[] args) {
        System.out.println(longestUniqueSubstring("abcabcbb")); // "abc"
        System.out.println(longestUniqueSubstring("bbbbb"));    // "b"
        System.out.println(longestUniqueSubstring("pwwkew"));   // "wke"
        System.out.println(longestUniqueSubstring(""));         // ""
        System.out.println(longestUniqueSubstring("dvdf"));     // "vdf"
        System.out.println(longestUniqueSubstring("abcbdeafgh"));// "cbdeafgh"
    }
}
```

---

## Dry Run Example: `"pwwkew"`

| Step | char | start | end | map               | window | maxLength | maxStart |
| ---- | ---- | ----- | --- | ----------------- | ------ | --------- | -------- |
| 0    | p    | 0     | 0   | {p:0}             | p      | 1         | 0        |
| 1    | w    | 0     | 1   | {p:0, w:1}        | pw     | 2         | 0        |
| 2    | w    | 0→2   | 2   | {p:0, w:2}        | w      | 2         | 0        |
| 3    | k    | 2     | 3   | {p:0, w:2, k:3}   | wk     | 2→2       | 0→?      |
| 4    | e    | 2     | 4   | {p:0,w:2,k:3,e:4} | wke    | 3         | 2        |
| 5    | w    | 2→3   | 5   | {p:0,w:5,k:3,e:4} | kew    | 3         | 2        |

**Result:** `"wke"`

---

## Test Cases

| Input          | Output       |
| -------------- | ------------ |
| `"abcabcbb"`   | `"abc"`      |
| `"bbbbb"`      | `"b"`        |
| `"pwwkew"`     | `"wke"`      |
| `""`           | `""`         |
| `"dvdf"`       | `"vdf"`      |
| `"abcbdeafgh"` | `"cbdeafgh"` |

---

