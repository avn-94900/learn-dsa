## Minimum distance between 2 words counting the number of characters from middle of both words. 

## ðŸ”¹ O(N) Approach (Single Pass)

1. Traverse the text from **left to right**.
2. At each position, check if substring starting here matches `w1` or `w2`.
3. If `w1` found â†’ compute its **midpoint** and compare with last seen `w2` midpoint.
4. If `w2` found â†’ compute its **midpoint** and compare with last seen `w1` midpoint.
5. Keep updating the **minimum distance**.
6. Continue until the end.

---

### Java Code (O(N))

```java
public class MinDistanceLinear {
    public static int minDistance(String text, String w1, String w2) {
        int n = text.length();
        int minDist = Integer.MAX_VALUE;

        int lastW1 = -1, lastW2 = -1; // store last seen midpoints

        int maxWL = Math.max(w1.length(), w2.length());

        for (int i = 0; i <= n - maxWL; i++) {
            // check if word1 starts at i
            if (text.startsWith(w1, i)) {
                int mid1 = i + w1.length() / 2;
                lastW1 = mid1;
                if (lastW2 != -1) {
                    minDist = Math.min(minDist, Math.abs(mid1 - lastW2));
                }
            }

            // check if word2 starts at i
            if (text.startsWith(w2, i)) {
                int mid2 = i + w2.length() / 2;
                lastW2 = mid2;
                if (lastW1 != -1) {
                    minDist = Math.min(minDist, Math.abs(mid2 - lastW1));
                }
            }
        }

        return (minDist == Integer.MAX_VALUE) ? -1 : minDist;
    }

    public static void main(String[] args) {
        String text = "this document contains many words even target and target can be repeated so many times";
        String w1 = "document";
        String w2 = "target";

        int result = minDistance(text, w1, w2);
        System.out.println("Minimum distance = " + result);
    }
}
```

---

### âœ… Complexity

* **Time:** `O(N)` (we scan each character once, substring check is O(1) amortized for small words).
* **Space:** `O(1)` (just store last seen positions).

---

ðŸ‘‰ This is the most efficient approach.
Would you like me to also adapt this for **case-insensitive + punctuation removal** (e.g., `"Target,"` vs `"target"`)?
