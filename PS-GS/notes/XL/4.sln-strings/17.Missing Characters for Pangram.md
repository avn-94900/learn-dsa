Got it âœ… â€” you want the method to

1. Return `-1` if **no characters are missing** (pangram case).
2. Return the **missing characters string** if some are missing.
3. Have **comments explaining time & space complexity** (both for the method overall, and for external calls like `toLowerCase()`).

---

### ðŸ”¹ Updated Java Code

```java
import java.util.*;

class Main {

    /**
     * Method: getMissingCharsForPangram
     * ---------------------------------
     * Finds which characters are missing to make the input string a pangram.
     *
     * Time Complexity:
     *   - O(n) â†’ where n = length of the string (for scanning all characters)
     *   - O(26) â†’ for checking missing characters (constant)
     *   => Overall: O(n)
     *
     * Space Complexity:
     *   - O(26) for boolean visited array (constant space)
     *   - O(26) for StringBuilder (at most 26 chars missing)
     *   => Overall: O(1) auxiliary space
     *
     * Note:
     *   - str.toLowerCase() â†’ O(n) time, O(n) space (creates a new lowercase copy of string)
     */
    public static String getMissingCharsForPangram(String str) {
        // Convert to lowercase: O(n) time, O(n) space
        str = str.toLowerCase();

        // Boolean array to track presence of each letter
        boolean[] visited = new boolean[26];

        // Step 1: Mark characters present â†’ O(n)
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (ch >= 'a' && ch <= 'z') {
                visited[ch - 'a'] = true;
            }
        }

        // Step 2: Collect missing characters â†’ O(26) = O(1)
        StringBuilder missing = new StringBuilder();
        for (int i = 0; i < 26; i++) {
            if (!visited[i]) {
                missing.append((char) ('a' + i));
            }
        }

        // Step 3: Return result
        return missing.length() == 0 ? "-1" : missing.toString();
    }

    public static void main(String[] args) {
        System.out.println(getMissingCharsForPangram("The quick brown fox jumps over lazy dog")); // -1
        System.out.println(getMissingCharsForPangram("hello world")); // abcfgijkmnpqstuvxyz
    }
}
```

---

### ðŸ”¹ Example Runs

**Input:** `"The quick brown fox jumps over lazy dog"`
âœ… Output: `-1`

**Input:** `"hello world"`
âœ… Output: `abcfgijkmnpqstuvxyz`

---

<br/><br/><br/><br/><br/><br/>

# ðŸ“ Problem Statement

A **pangram** is a sentence that contains **all 26 letters** of the English alphabet at least once.
Given a string `s`, return all the **missing characters** that must be added to make it a pangram.

---

# ðŸ“¥ Input Format

* A single string `s`, containing letters, spaces, digits, or punctuation.

# ðŸ“¤ Output Format

* A string containing the missing letters in **alphabetical order**.
* If the string is already a pangram, return `"None"` or an empty string.

---

# âœ… Example 1

**Input:**

```
The quick brown fox jumps over the lazy dog
```

**Output:**

```
None
```

**Explanation:**

* This is already a pangram â†’ no missing letters.

---

# âœ… Example 2

**Input:**

```
welcome to coding
```

**Output:**

```
abfhjklmpqrsuvxz
```

**Explanation:**

* Present letters: `c, d, e, g, i, l, n, o, t, w`
* Missing letters: `a, b, f, h, j, k, m, p, q, r, s, u, v, x, z`

---

# ðŸ› ï¸ Approaches

---

## 1ï¸âƒ£ Brute Force Approach

### Logic

* Create a list of all 26 letters.
* For each letter, check if it is present in the input string.
* Collect all missing ones.

### Java Code â€“ Brute Force

```java
import java.util.*;

public class MissingPangramBruteForce {

    public static String findMissingLetters(String s) {
        s = s.toLowerCase(); // convert to lowercase
        String alphabet = "abcdefghijklmnopqrstuvwxyz";
        StringBuilder missing = new StringBuilder();

        // Check for each letter in alphabet
        for (char c : alphabet.toCharArray()) {
            if (s.indexOf(c) == -1) { // not present in string
                missing.append(c);
            }
        }

        return missing.length() == 0 ? "None" : missing.toString();
    }

    public static void main(String[] args) {
        System.out.println(findMissingLetters("The quick brown fox jumps over the lazy dog")); 
        // None

        System.out.println(findMissingLetters("welcome to coding")); 
        // abfhjklmpqrsuvxz
    }
}
```

### Complexity (Brute Force)

* **Time:** `O(26 * n)` â‰ˆ `O(n)` â†’ for each alphabet letter, scan the string.
* **Space:** `O(1)` (only result string).

---

## 2ï¸âƒ£ Optimized Approach â€“ Using HashSet / Boolean Array

### Logic

* Use a `boolean[26]` or `HashSet` to track which letters appear.
* At the end, collect the letters that are still missing.

### Java Code â€“ Optimized

```java
import java.util.*;

public class MissingPangramOptimized {

    public static String findMissingLetters(String s) {
        boolean[] seen = new boolean[26]; // track letters
        s = s.toLowerCase();

        // Mark seen letters
        for (char c : s.toCharArray()) {
            if (c >= 'a' && c <= 'z') {
                seen[c - 'a'] = true;
            }
        }

        // Collect missing ones
        StringBuilder missing = new StringBuilder();
        for (int i = 0; i < 26; i++) {
            if (!seen[i]) {
                missing.append((char) (i + 'a'));
            }
        }

        return missing.length() == 0 ? "None" : missing.toString();
    }

    public static void main(String[] args) {
        System.out.println(findMissingLetters("The quick brown fox jumps over the lazy dog")); 
        // None

        System.out.println(findMissingLetters("welcome to coding")); 
        // abfhjklmpqrsuvxz
    }
}
```

### Complexity (Optimized)

* **Time:** `O(n)` â†’ single pass through input string.
* **Space:** `O(1)` â†’ fixed boolean\[26].

---

# ðŸ“Š Comparison Table

| Approach    | Time Complexity      | Space Complexity | Notes                               |
| ----------- | -------------------- | ---------------- | ----------------------------------- |
| Brute Force | `O(26 * n)` â‰ˆ `O(n)` | `O(1)`           | Simple, direct string checks.       |
| Optimized   | `O(n)`               | `O(1)`           | More efficient, clean, best choice. |

---

âœ… With this, you now have:

* **Input/Output format**
* **2 explained examples**
* **Brute force + Optimized Java code with inline notes**
* **Time/Space complexities & comparison**

---

ðŸ‘‰ Do you want me to also extend this so it **prints the number of missing characters** along with the letters (some interviewers like that)?
