# Comprehensive Array Problems Guide

## Table of Contents
1. [2nd Smallest Element of an Unsorted Array](#1-2nd-smallest-element-of-an-unsorted-array)
2. [2nd Smallest Element of a Sorted Rotated Array](#2-2nd-smallest-element-of-a-sorted-rotated-array)
3. [Find Second Largest Element in an Array](#3-find-second-largest-element-in-an-array)
4. [Find Number of Pairs in Array with Given Sum](#4-find-number-of-pairs-in-array-with-given-sum)
5. [Find Sum of Product of All Pairs](#5-find-sum-of-product-of-all-pairs)
6. [Longest Sub-array with Sum K](#6-longest-sub-array-with-sum-k)
7. [Possible to Make a Divisible by 3 Number](#7-possible-to-make-a-divisible-by-3-number)
8. [Check if Array is Stack Sortable](#8-check-if-array-is-stack-sortable)
9. [Arrange Numbers to Form Biggest Number](#9-arrange-numbers-to-form-biggest-number)
10. [Find Maximum Average from Employee Data](#10-find-maximum-average-from-employee-data)
11. [Smallest Subarray with Sum ≥ Target](#11-smallest-subarray-with-sum--target)
12. [Find Dot Product of Two Arrays](#12-find-dot-product-of-two-arrays)
13. [Find Mean and Median of Unsorted Array](#13-find-mean-and-median-of-unsorted-array)

---

## **1. 2nd Smallest Element of an Unsorted Array**

### Problem Statement
Find the second smallest element in an unsorted array. If no second smallest exists (array has less than 2 elements or all elements are same), return -1.

### Approach: Single Pass with Two Variables
**Logic:** Track the smallest and second smallest elements in a single pass through the array.

```java
public class SecondSmallestUnsorted {
    public static int secondSmallest(int[] arr) {
        if (arr.length < 2) return -1; // Not enough elements

        int first = Integer.MAX_VALUE;
        int second = Integer.MAX_VALUE;

        for (int num : arr) {
            if (num < first) {
                second = first;
                first = num;
            } else if (num > first && num < second) {
                second = num;
            }
        }

        return (second == Integer.MAX_VALUE) ? -1 : second;
    }

    public static void main(String[] args) {
        int[] arr = {7, 2, 9, 4, 2, 5};
        System.out.println(secondSmallest(arr)); // Output: 4
    }
}
```

**Complexity:**
- Time: **O(n)** (single pass)
- Space: **O(1)**

**Edge Cases:**
- Array with duplicates
- Array with all same elements
- Array with less than 2 elements
- Array with negative numbers

---

## **2. 2nd Smallest Element of a Sorted Rotated Array**

### Problem Statement
Find the second smallest element in a sorted array that has been rotated. For example, [4,5,6,1,2,3] is a rotated version of [1,2,3,4,5,6].

### Approach: Binary Search to Find Pivot
**Logic:** Find the rotation point (smallest element) using binary search, then the second smallest is the next element.

```java
public class SecondSmallestSortedRotated {
    public static int secondSmallest(int[] arr) {
        int n = arr.length;
        if (n < 2) return -1;

        // Find index of minimum element (pivot) using binary search
        int low = 0, high = n - 1;
        while (low < high) {
            int mid = (low + high) / 2;
            if (arr[mid] > arr[high]) low = mid + 1;
            else high = mid;
        }
        int smallestIndex = low;

        // 2nd smallest is either next element (circular check)
        return arr[(smallestIndex + 1) % n];
    }

    public static void main(String[] args) {
        int[] arr = {4, 5, 6, 1, 2, 3};
        System.out.println(secondSmallest(arr)); // Output: 2
    }
}
```

**Complexity:**
- Time: **O(log n)** (binary search)
- Space: **O(1)**

**Edge Cases:**
- No rotation (already sorted)
- Single rotation
- Array with duplicates

---

## **3. Find Second Largest Element in an Array**

### Problem Statement
Find the second largest element in an unsorted array. Similar to second smallest but finding the maximum values.

### Approach: Single Pass with Two Variables
**Logic:** Track the largest and second largest elements in a single pass.

```java
public class SecondLargest {
    public static int secondLargest(int[] arr) {
        if (arr.length < 2) return -1;

        int first = Integer.MIN_VALUE;
        int second = Integer.MIN_VALUE;

        for (int num : arr) {
            if (num > first) {
                second = first;
                first = num;
            } else if (num < first && num > second) {
                second = num;
            }
        }

        return (second == Integer.MIN_VALUE) ? -1 : second;
    }

    public static void main(String[] args) {
        int[] arr = {7, 2, 9, 4, 2, 5};
        System.out.println(secondLargest(arr)); // Output: 7
    }
}
```

**Complexity:**
- Time: **O(n)** 
- Space: **O(1)**

**Edge Cases:**
- Array with all same elements
- Array with duplicates
- Negative numbers

---

## **4. Find Number of Pairs in Array with Given Sum**

### Problem Statement
Count the number of pairs in an array that sum up to a given target value. Each element can be used in multiple pairs.

### Approach: HashMap for Complement Tracking
**Logic:** For each element, check if its complement (target - element) exists in the map.

```java
import java.util.*;

public class PairsWithSum {
    
    // brute force approach
    public static int countPairs(int[] arr, int target) {
        int n = arr.length;
        int count = 0;

        // Check every possible pair
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] + arr[j] == target) {
                    count++;
                }
            }
        }
        return count;
    }

    // optmized one using hashmap
    public static int countPairs(int[] arr, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int count = 0;

        for (int num : arr) {
            int complement = target - num;

            // If complement already exists, increment count by its frequency
            if (map.containsKey(complement)) {
                count += map.get(complement);
            }

            // Add current num to map
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        return count;
    }

    public static void main(String[] args) {
        int[] arr = {1, 5, 7, -1, 5};
        int target = 6;
        System.out.println(countPairs(arr, target)); // Output: 3
    }
}
```

**Complexity:**
- Time: **O(n)**
- Space: **O(n)** (hashmap for frequency)

**Edge Cases:**
- Duplicate elements
- Target sum is twice an element value
- No pairs exist
- Negative numbers

---

## **5. Find Sum of Product of All Pairs**

### Problem Statement
Calculate the sum of products of all possible pairs of elements. For array [1,2,3], pairs are (1,2), (1,3), (2,3) and sum = 1×2 + 1×3 + 2×3 = 11.

### Brute Force Approach
```java
public class SumOfProductsBruteForce {
    // Time: O(n²), Space: O(1)
    public static long sumOfProducts(int[] arr) {
        if (arr == null || arr.length < 2) return 0;
        
        long sum = 0;
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                sum += (long) arr[i] * arr[j];
            }
        }
        return sum;
    }
}
```

### Optimized Approach: Mathematical Formula
**Logic:** Use formula: sum of products = ((sum of all elements)² - sum of squares) / 2

```java
public class SumOfProductsOptimized {
    // Time: O(n), Space: O(1)
    public static long sumOfProducts(int[] arr) {
        if (arr == null || arr.length < 2) return 0;
        
        long sum = 0;
        long sumOfSquares = 0;
        
        for (int num : arr) {
            sum += num;
            sumOfSquares += (long) num * num;
        }
        
        return (sum * sum - sumOfSquares) / 2;
    }
}
```

**Complexity:**
- Brute Force: Time **O(n²)**, Space **O(1)**
- Optimized: Time **O(n)**, Space **O(1)**

---

## **6. Longest Sub-array with Sum K**

### Problem Statement
Find the length of the longest contiguous sub-array that has sum equal to K. Array can contain positive, negative, and zero values.

### Brute Force Approach
```java
public class LongestSubarraySumKBruteForce {

    // Time: O(n²), Space: O(1)
    public static int findLongestSubarray(int[] arr, int k) {
        if (arr == null || arr.length == 0) return 0;

        int maxLength = 0;
        for (int i = 0; i < arr.length; i++) {  // starting index
            int sum = 0;
            for (int j = i; j < arr.length; j++) {   // ending index
                sum += arr[j]; // ✅ accumulate arr[j], not arr[i]
                if (sum == k) {
                    maxLength = Math.max(maxLength, j - i + 1);
                }
            }
        }
        return maxLength;
    }
}
```

### Optimized Approach: Prefix Sum with HashMap
**Logic:** Use prefix sum with HashMap. If (currentSum - K) exists in map, we found a sub-array.

```java
import java.util.*;

public class LongestSubarraySumK {
    public static int longestSubarray(int[] arr, int k) {
        Map<Integer, Integer> map = new HashMap<>(); // prefixSum -> firstIndex
        int prefixSum = 0, maxLen = 0;

        for (int i = 0; i < arr.length; i++) {
            prefixSum += arr[i];

            // Case 1: if prefix itself equals k
            if (prefixSum == k) {
                maxLen = i + 1;
            }

            // Case 2: if (prefixSum - k) seen before
            if (map.containsKey(prefixSum - k)) {
                int len = i - map.get(prefixSum - k);
                maxLen = Math.max(maxLen, len);
            }

            // Store prefix sum if not seen before
            map.putIfAbsent(prefixSum, i);
        }

        return maxLen;
    }
}
```

**Complexity:**
- Brute Force: Time **O(n³)**, Space **O(1)**
- Optimized: Time **O(n)**, Space **O(n)**

---

## **7. Possible to Make a Divisible by 3 Number**

### Problem Statement
Given an array of digits (0-9), determine if it's possible to arrange all digits to form a number divisible by 3.

### Brute Force Approach
Generate all permutations and check each one.

### Optimized Approach: Divisibility Rule
**Logic:** A number is divisible by 3 if sum of its digits is divisible by 3.

```java
public class DivisibleBy3Optimized {
    // Time: O(n), Space: O(1)
    public static boolean canFormDivisibleBy3(int[] digits) {
        if (digits == null || digits.length == 0) return false;
        
        int sum = 0;
        for (int digit : digits) {
            sum += digit;
        }
        
        return sum % 3 == 0;
    }
}
```

**Complexity:**
- Brute Force: Time **O(n! × n)**, Space **O(n!)**
- Optimized: Time **O(n)**, Space **O(1)**

---

## **8. Check if Array is Stack Sortable**

### Problem Statement
Determine if an array can be sorted using an auxiliary stack with only push/pop operations, processing input elements in order.

### Approach: Greedy Simulation
**Logic:** Push elements to stack, pop when top element is the next expected in sorted order.

```java
import java.util.Stack;

public class IsStackSortable {

    public static void main(String[] args) {
        System.out.println(isStackSortable(new int[]{2, 3, 1}));   // false
        System.out.println(isStackSortable(new int[]{4, 2, 3, 1})); // false

        /*
         Example:
         Input: [4, 1, 3, 2]
         Expected Output: true

         Steps:
         - push 4 to stack
         - push 1 to stack
         - pop 1 from stack → append to array
         - push 3 to stack
         - push 2 to stack
         - pop 2, 3, 4 from stack → append to array
        */
        System.out.println(isStackSortable(new int[]{4, 1, 3, 2})); // true
    }

    /**
     * Checks if the given array can be sorted using a stack-based process.
     *
     * Time Complexity: O(N)  (each element is pushed and popped at most once)
     * Space Complexity: O(N) (stack usage)
     */
    public static boolean isStackSortable(int[] array) {
        Stack<Integer> stack = new Stack<>();
        int lastPopped = Integer.MIN_VALUE;

        for (int num : array) {
            // Pop elements smaller than current number
            while (!stack.isEmpty() && stack.peek() < num) {
                lastPopped = stack.pop();
            }

            // If current number is smaller than last popped → not sortable
            if (num < lastPopped) {
                return false;
            }

            stack.push(num);
        }
        return true;
    }
}
```
### print sorted array 
```java
import java.util.Stack;
import java.util.ArrayList;
import java.util.List;

public class IsStackSortable {

    public static void main(String[] args) {
        System.out.println(isStackSortable(new int[]{2, 3, 1}));   // false
        System.out.println(isStackSortable(new int[]{4, 2, 3, 1})); // false
        System.out.println(isStackSortable(new int[]{4, 1, 3, 2})); // true
    }

    /**
     * Checks if the given array can be sorted using a stack-based process.
     *
     * Time Complexity: O(N)  (each element is pushed and popped at most once)
     * Space Complexity: O(N) (stack usage + output list)
     */
    public static boolean isStackSortable(int[] array) {
        Stack<Integer> stack = new Stack<>();
        List<Integer> output = new ArrayList<>();
        int lastPopped = Integer.MIN_VALUE;

        for (int num : array) {
            // Pop elements smaller than current number
            while (!stack.isEmpty() && stack.peek() < num) {
                lastPopped = stack.pop();
                output.add(lastPopped);
            }

            // If current number is smaller than last popped → not sortable
            if (num < lastPopped) {
                return false;
            }

            stack.push(num);
        }

        // Pop remaining elements from stack
        while (!stack.isEmpty()) {
            output.add(stack.pop());
        }

        // Print the sorted array
        // Sorted sequence: [1, 2, 3, 4]
        System.out.println("Sorted sequence: " + output);

        return true;
    }
}
```

**Complexity:**
- Time: **O(n)**
- Space: **O(n)**

---

## **9. Arrange Numbers to Form Biggest Number**

### Problem Statement
Given an array of non-negative integers, arrange them to form the largest possible number.

### Approach: Custom Comparator
**Logic:** Compare numbers by checking which concatenation order (ab vs ba) produces larger result.

```java
import java.util.Arrays;
import java.util.Comparator;

public class BiggestNumber {
    public static String largestNumber(int[] nums) {
        String[] arr = Arrays.stream(nums).mapToObj(String::valueOf).toArray(String[]::new);

        Arrays.sort(arr, (a, b) -> (b + a).compareTo(a + b));

        if (arr[0].equals("0")) return "0";

        return String.join("", arr);
    }

    public static void main(String[] args) {
        int[] nums = {3, 30, 34, 5, 9};
        System.out.println(largestNumber(nums)); // Output: 9534330
    }
}
```

**Complexity:**
- Time: **O(n log n × k)** (k = max digits in a number)
- Space: **O(n)**

---

## **10. Find Maximum Average from Employee Data**

### Problem Statement
Given an array of employees with name and marks, find the employee(s) with maximum average marks.

### Approach: HashMap for Aggregation
**Logic:** Group by employee name, calculate averages, find maximum.

```java
import java.util.*;

public class MaxAverageMarks {
    public static void main(String[] args) {
        String[][] arr = {
            {"Alia","-678"},
            {"Bobby","100"},
            {"Alex","223"},
            {"Alex","-23"},
            {"Bobby","723"}
        };

        // Step 1: Group marks by employee name
        Map<String, List<Integer>> employeeMarks = new HashMap<>();
        for (String[] emp : arr) {
            String name = emp[0];
            int marks = Integer.parseInt(emp[1]);
            if (!employeeMarks.containsKey(name)) {
                employeeMarks.put(name, new ArrayList<>());
            }
            employeeMarks.get(name).add(marks);
        }

        // Step 2: Calculate averages and find max
        String topEmployee = null;
        double maxAverage = Double.NEGATIVE_INFINITY;

        for (Map.Entry<String, List<Integer>> entry : employeeMarks.entrySet()) {
            List<Integer> marksList = entry.getValue();
            int sum = 0;
            for (int marks : marksList) {
                sum += marks;
            }
            double average = (double) sum / marksList.size();

            if (average > maxAverage) {
                maxAverage = average;
                topEmployee = entry.getKey();
            }
        }

        // Step 3: Print result
        System.out.println(topEmployee + " = " + maxAverage);
    }
}
```
<br/>

```java
import java.util.*;
import java.util.stream.*;

public class MaxAverageMarksStream {
    public static void main(String[] args) {
        String[][] arr = {
            {"Alia","-678"},
            {"Bobby","100"},
            {"Alex","223"},
            {"Alex","-23"},
            {"Bobby","723"}
        };

        // Step 1: Convert to a Stream
        Map<String, Double> avgMap = Arrays.stream(arr)
            .collect(Collectors.groupingBy(
                emp -> emp[0],  // group by name
                Collectors.averagingInt(emp -> Integer.parseInt(emp[1])) // average marks
            ));

        // Step 2: Find max average
        Map.Entry<String, Double> result = avgMap.entrySet()
            .stream()
            .max(Map.Entry.comparingByValue())
            .orElse(null);

        if (result != null) {
            System.out.println(result.getKey() + " = " + result.getValue());
        }
    }
}
```

**Complexity:**
- Time: **O(n)**
- Space: **O(n)**

---

## **11. Smallest Subarray with Sum ≥ Target**

### Problem Statement
Find the minimum length of a contiguous subarray whose sum is greater than or equal to target.

### Approach: Sliding Window
**Logic:** Use two pointers to maintain a window, expand when sum < target, contract when sum ≥ target.

```java
public class MinSubarraySum {
    public static int minSubArrayLen(int target, int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        
        int left = 0;
        int sum = 0;
        int minLen = Integer.MAX_VALUE;
        
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            
            while (sum >= target) {
                minLen = Math.min(minLen, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

**Complexity:**
- Time: **O(n)**
- Space: **O(1)**

---

## **12. Find Dot Product of Two Arrays**

### Problem Statement
Calculate the dot product of two arrays of equal length. Dot product = sum of products of corresponding elements.

### Approach: Single Pass Multiplication
**Logic:** Iterate through both arrays simultaneously and sum the products.

```java
public class DotProduct {
    public static long dotProduct(int[] arr1, int[] arr2) {
        if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
            throw new IllegalArgumentException("Arrays must be non-null and of equal length");
        }
        
        long result = 0;
        
        for (int i = 0; i < arr1.length; i++) {
            result += (long) arr1[i] * arr2[i]; // Use long to prevent overflow
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = {4, 5, 6};
        System.out.println(dotProduct(arr1, arr2)); // Output: 32 (1*4 + 2*5 + 3*6)
    }
}
```

**Complexity:**
- Time: **O(n)**
- Space: **O(1)**

**Edge Cases:**
- Arrays of different lengths
- Empty arrays
- Arrays with negative numbers
- Large numbers causing overflow

---

## **13. Find Mean and Median of Unsorted Array**

### Problem Statement
Calculate both the arithmetic mean (average) and median (middle value when sorted) of an unsorted array.

### Approach: Partial Sorting for Median
**Logic:** Calculate mean in O(n), use quickselect or sorting for median.

```java
import java.util.Arrays;

public class MeanAndMedian {
    public static class Result {
        double mean;
        double median;
        
        Result(double mean, double median) {
            this.mean = mean;
            this.median = median;
        }
        
        @Override
        public String toString() {
            return String.format("Mean: %.2f, Median: %.2f", mean, median);
        }
    }
```
<br/>

```java    
    public static Result findMeanAndMedian(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("Array cannot be null or empty");
        }
        
        // Calculate mean - O(n)
        long sum = 0;
        for (int num : arr) {
            sum += num;
        }
        double mean = (double) sum / arr.length;
        
        // Calculate median - O(n log n) with sorting
        int[] sortedArr = arr.clone();
        Arrays.sort(sortedArr);
        
        double median;
        int n = sortedArr.length;
        if (n % 2 == 0) {
            median = (sortedArr[n/2 - 1] + sortedArr[n/2]) / 2.0;
        } else {
            median = sortedArr[n/2];
        }
        
        return new Result(mean, median);
    }
```
<br/>

```java  
    // Optimized median using QuickSelect - O(n) average case
    public static double findMedianQuickSelect(int[] arr) {
        int n = arr.length;
        if (n % 2 == 1) {
            return quickSelect(arr.clone(), 0, n - 1, n / 2);
        } else {
            int[] temp = arr.clone();
            double left = quickSelect(temp, 0, n - 1, n / 2 - 1);
            temp = arr.clone(); // Reset array as quickSelect modifies it
            double right = quickSelect(temp, 0, n - 1, n / 2);
            return (left + right) / 2.0;
        }
    }
    
    private static double quickSelect(int[] arr, int left, int right, int k) {
        if (left == right) return arr[left];
        
        int pivotIndex = partition(arr, left, right);
        
        if (k == pivotIndex) {
            return arr[k];
        } else if (k < pivotIndex) {
            return quickSelect(arr, left, pivotIndex - 1, k);
        } else {
            return quickSelect(arr, pivotIndex + 1, right, k);
        }
    }
    
    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right];
        int i = left;
        
        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                swap(arr, i, j);
                i++;
            }
        }
        swap(arr, i, right);
        return i;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6};
        Result result = findMeanAndMedian(arr);
        System.out.println(result); // Mean: 3.88, Median: 3.50
        
        System.out.println("Median (QuickSelect): " + findMedianQuickSelect(arr));
    }
}
```

**Complexity:**
- Mean: Time **O(n)**, Space **O(1)**
- Median (Sorting): Time **O(n log n)**, Space **O(n)**
- Median (QuickSelect): Time **O(n)** average, **O(n²)** worst case, Space **O(log n)**

**Edge Cases:**
- Single element array
- Even vs odd length arrays
- Arrays with duplicate values
- Large numbers causing overflow in sum
- All elements are the same

---

## **Summary Table**

| Problem | Optimal Time | Space | Key Technique |
|---------|-------------|-------|---------------|
| 2nd Smallest (Unsorted) | O(n) | O(1) | Two variables tracking |
| 2nd Smallest (Rotated) | O(log n) | O(1) | Binary search for pivot |
| 2nd Largest | O(n) | O(1) | Two variables tracking |
| Pairs with Sum | O(n) | O(n) | HashMap complement |
| Sum of Products | O(n) | O(1) | Mathematical formula |
| Longest Subarray Sum K | O(n) | O(n) | Prefix sum + HashMap |
| Divisible by 3 | O(n) | O(1) | Divisibility rule |
| Stack Sortable | O(n) | O(n) | Greedy simulation |
| Biggest Number | O(n log n) | O(n) | Custom comparator |
| Max Average Employee | O(n) | O(n) | HashMap aggregation |
| Min Subarray Sum ≥ Target | O(n) | O(1) | Sliding window |
| Dot Product | O(n) | O(1) | Element-wise multiplication |
| Mean and Median | O(n log n) | O(n) | Sorting / QuickSelect |

This comprehensive guide covers all the array problems with multiple approaches, complexity analysis, and edge cases for thorough understanding and interview preparation.