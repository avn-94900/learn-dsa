Here’s a **complete, structured solution** for finding the **first repeating character index** and the **length of the repeating substring** in a string:

---

## 1. **Problem Statement & Example**

**Problem:**
Given a string `s`, find the **index of the first character that repeats** and the **length of the substring between its first and second occurrence** (inclusive of both occurrences).

**Example 1:**

```
Input: s = "abca"
Output: firstRepeatingIndex = 0, length = 4
Explanation: 'a' repeats at index 3. Substring "abca" length = 4
```

**Example 2:**

```
Input: s = "geeksforgeeks"
Output: firstRepeatingIndex = 0, length = 8
Explanation: 'g' repeats at index 7. Substring "geeksforg" length = 8
```

**Example 3:**

```
Input: s = "abcd"
Output: firstRepeatingIndex = -1, length = 0
Explanation: No repeating character
```

---

## 2. **Approaches**

### **Approach 1: Brute Force**

**Logic:**

* Check every character against all subsequent characters to find first repetition.
* Track first occurrence and second occurrence, calculate substring length.

**Time Complexity:** `O(n^2)`
**Space Complexity:** `O(1)`

**Use Case:** Small strings or when performance is not critical.

---

### **Approach 2: Optimized using HashMap**

**Logic:**

* Use a `Map<Character, Integer>` to store first index of each character.
* Iterate over the string:

  * If character seen before → calculate substring length → break for first repeating character.

**Time Complexity:** `O(n)`
**Space Complexity:** `O(n)`

**Use Case:** Large strings, efficient solution.

---

### **Approach 3: Using Fixed-Size Array (if ASCII)**

**Logic:**

* If string contains only ASCII characters, use `int[256]` array instead of HashMap.
* Same logic as hashmap.

**Time Complexity:** `O(n)`
**Space Complexity:** `O(1)` (constant 256 size)

**Use Case:** Optimized for ASCII strings.

---

### **Approach 4: Streams / Functional Java 8+**

**Logic:**

* Use streams to map characters to indices and find first repetition.
* Less performant for large strings due to stream overhead.

**Time Complexity:** `O(n)`
**Space Complexity:** `O(n)`

**Use Case:** Clean, functional-style code.

---

## 3. **Comparison Table**

| Approach                 | Time Complexity | Space Complexity | Notes                              |
| ------------------------ | --------------- | ---------------- | ---------------------------------- |
| Brute Force              | O(n²)           | O(1)             | Simple, inefficient for large n    |
| HashMap                  | O(n)            | O(n)             | Efficient, works for any charset   |
| Fixed-size Array (ASCII) | O(n)            | O(1)             | Most efficient if input is ASCII   |
| Streams / Functional     | O(n)            | O(n)             | Clean but slightly slower than map |

---

## 4. **Java Code Examples**

### **4.1 Brute Force**

```java
public class FirstRepeatingBruteForce {
    public static void main(String[] args) {
        String s = "geeksforgeeks";
        int firstIndex = -1;
        int length = 0;

        for (int i = 0; i < s.length(); i++) {
            for (int j = i + 1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    firstIndex = i;
                    length = j - i + 1;
                    break;
                }
            }
            if (firstIndex != -1) break;
        }

        System.out.println("First Repeating Index: " + firstIndex);
        System.out.println("Length: " + length);
    }
}
```

---

### **4.2 HashMap Optimized**

```java
import java.util.*;

public class FirstRepeatingOptimized {
    public static void main(String[] args) {
        String s = "geeksforgeeks";
        Map<Character, Integer> map = new HashMap<>();
        int firstIndex = -1;
        int length = 0;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) {
                firstIndex = map.get(c);
                length = i - firstIndex + 1;
                break;
            } else {
                map.put(c, i);
            }
        }

        System.out.println("First Repeating Index: " + firstIndex);
        System.out.println("Length: " + length);
    }
}
```

---

### **4.3 Fixed-Size Array (ASCII)**

```java
public class FirstRepeatingASCII {
    public static void main(String[] args) {
        String s = "geeksforgeeks";
        int[] index = new int[256];
        Arrays.fill(index, -1);

        int firstIndex = -1;
        int length = 0;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (index[c] != -1) {
                firstIndex = index[c];
                length = i - firstIndex + 1;
                break;
            } else {
                index[c] = i;
            }
        }

        System.out.println("First Repeating Index: " + firstIndex);
        System.out.println("Length: " + length);
    }
}
```

---

### **4.4 Java 8 Streams**

```java
import java.util.*;
import java.util.stream.*;

public class FirstRepeatingStream {
    public static void main(String[] args) {
        String s = "geeksforgeeks";
        Map<Character, Integer> map = new HashMap<>();
        OptionalInt firstIndexOpt = IntStream.range(0, s.length())
            .filter(i -> {
                char c = s.charAt(i);
                if (map.containsKey(c)) return true;
                map.put(c, i);
                return false;
            }).findFirst();

        if (firstIndexOpt.isPresent()) {
            int i = firstIndexOpt.getAsInt();
            int firstIndex = map.get(s.charAt(i));
            int length = i - firstIndex + 1;
            System.out.println("First Repeating Index: " + firstIndex);
            System.out.println("Length: " + length);
        } else {
            System.out.println("First Repeating Index: -1");
            System.out.println("Length: 0");
        }
    }
}
```

---

## 5. **Test Cases & Edge Cases**

| Test Case        | Input           | Output | Notes                           |
| ---------------- | --------------- | ------ | ------------------------------- |
| Normal case      | "abca"          | 0, 4   | 'a' repeats                     |
| Multiple repeats | "geeksforgeeks" | 0, 8   | First repeating is 'g'          |
| No repeat        | "abcd"          | -1, 0  | No repeating characters         |
| Repeat at end    | "abcdeaf"       | 0, 6   | 'a' repeats at last position    |
| All same chars   | "aaaa"          | 0, 2   | First repetition 'a' at index 1 |
| Single char      | "x"             | -1, 0  | No repeat possible              |
| Empty string     | ""              | -1, 0  | Edge case                       |

---

## 6. **Pitfalls & Best Practices**

* **Common mistakes:**

  * Forgetting to include both first and second occurrences when calculating substring length.
  * Using `==` instead of `.equals()` for string comparison (not for char).
  * Not handling empty strings.
  * Using `Map` but forgetting `break` after finding first repetition.

* **Best Practices:**

  * Prefer `HashMap` or fixed-size array for efficiency.
  * Always initialize variables to safe defaults (`-1` for index, `0` for length).
  * Test edge cases like empty strings or strings with all unique characters.

---

## 7. **JUnit Test Class (Optimized Approach)**

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class FirstRepeatingTest {

    @Test
    void testNormal() {
        assertArrayEquals(new int[]{0, 4}, getFirstRepeating("abca"));
    }

    @Test
    void testMultipleRepeats() {
        assertArrayEquals(new int[]{0, 8}, getFirstRepeating("geeksforgeeks"));
    }

    @Test
    void testNoRepeat() {
        assertArrayEquals(new int[]{-1, 0}, getFirstRepeating("abcd"));
    }

    @Test
    void testRepeatAtEnd() {
        assertArrayEquals(new int[]{0, 6}, getFirstRepeating("abcdeaf"));
    }

    @Test
    void testSingleChar() {
        assertArrayEquals(new int[]{-1, 0}, getFirstRepeating("x"));
    }

    int[] getFirstRepeating(String s) {
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) {
                return new int[]{map.get(c), i - map.get(c) + 1};
            } else {
                map.put(c, i);
            }
        }
        return new int[]{-1, 0};
    }
}
```

---

## 8. **Related / Follow-Up Questions**

* Find **all repeating characters** and their first occurrences.
* Find **longest repeating substring**.
* Solve for **case-insensitive strings**.
* Modify to work for **unicode characters** instead of ASCII.
* Return **both first and last repeating indices**.
* Use **sliding window** for streaming data instead of storing entire string.

---

If you want, I can also draw a **visual dry run diagram** for `"geeksforgeeks"` showing how the indices and lengths are calculated for **first repeating character** — it makes it extremely clear for interviews.

Do you want me to do that?
