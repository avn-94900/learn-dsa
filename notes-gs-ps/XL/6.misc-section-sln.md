

# âœ… 1. Return element from a Pascal Triangle

(Find element at row `r` and column `c`)

```java
public class PascalTriangleElement {

    // Brute Force: Generate entire Pascal Triangle up to row r
    public static int getElementBrute(int r, int c) {
        int[][] pascal = new int[r + 1][r + 1];

        for (int i = 0; i <= r; i++) {
            pascal[i][0] = pascal[i][i] = 1; // first and last elements are 1
            for (int j = 1; j < i; j++) {
                pascal[i][j] = pascal[i - 1][j - 1] + pascal[i - 1][j];
            }
        }
        return pascal[r][c];
    }
    // Time: O(r^2), Space: O(r^2)

    // Optimized: Use nCr formula directly â†’ n! / (r! * (n-r)!)
    public static int getElementOptimized(int r, int c) {
        return nCr(r, c);
    }

    private static int nCr(int n, int r) {
        long res = 1;
        r = Math.min(r, n - r); // symmetry property
        for (int i = 0; i < r; i++) {
            res = res * (n - i) / (i + 1);
        }
        return (int) res;
    }
    // Time: O(r), Space: O(1)

    public static void main(String[] args) {
        System.out.println(getElementBrute(5, 2));     // Output: 10
        System.out.println(getElementOptimized(5, 2)); // Output: 10
        System.out.println(getElementBrute(4, 1));     // Output: 4
        System.out.println(getElementOptimized(4, 1)); // Output: 4
    }
}
```

---

# âœ… 2. Reverse String and Fix Errors

```java
public class ReverseString {

    // Brute Force: Reverse using char array
    public static String reverseBrute(String s) {
        char[] arr = s.toCharArray();
        int i = 0, j = arr.length - 1;
        while (i < j) {
            char temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
        return new String(arr);
    }
    // Time: O(n), Space: O(n)

    // Optimized: Use StringBuilder reverse()
    public static String reverseOptimized(String s) {
        return new StringBuilder(s).reverse().toString();
    }
    // Time: O(n), Space: O(1)

    public static void main(String[] args) {
        System.out.println(reverseBrute("hello"));      // Output: "olleh"
        System.out.println(reverseOptimized("world"));  // Output: "dlrow"
    }
}
```

---

# âœ… 3. BST: Put, Contains, InOrder

```java
class BST {
    class Node {
        int val;
        Node left, right;
        Node(int val) { this.val = val; }
    }

    Node root;

    // Brute Force Put: Recursively insert
    public void putBrute(int val) {
        root = putBruteRec(root, val);
    }
    private Node putBruteRec(Node node, int val) {
        if (node == null) return new Node(val);
        if (val < node.val) node.left = putBruteRec(node.left, val);
        else if (val > node.val) node.right = putBruteRec(node.right, val);
        return node;
    }
    // Time: O(h), Space: O(h) stack

    // Optimized Put: Iterative
    public void putOptimized(int val) {
        if (root == null) {
            root = new Node(val);
            return;
        }
        Node curr = root;
        while (true) {
            if (val < curr.val) {
                if (curr.left == null) { curr.left = new Node(val); break; }
                curr = curr.left;
            } else if (val > curr.val) {
                if (curr.right == null) { curr.right = new Node(val); break; }
                curr = curr.right;
            } else break;
        }
    }
    // Time: O(h), Space: O(1)

    public boolean contains(int val) {
        Node curr = root;
        while (curr != null) {
            if (val == curr.val) return true;
            else if (val < curr.val) curr = curr.left;
            else curr = curr.right;
        }
        return false;
    }

    public void inorder(Node node) {
        if (node != null) {
            inorder(node.left);
            System.out.print(node.val + " ");
            inorder(node.right);
        }
    }

    public static void main(String[] args) {
        BST bst = new BST();
        bst.putBrute(5);
        bst.putBrute(3);
        bst.putBrute(7);
        bst.putOptimized(6);
        bst.inorder(bst.root); // Output: 3 5 6 7
        System.out.println("\nContains 6? " + bst.contains(6)); // true
        System.out.println("Contains 4? " + bst.contains(4));   // false
    }
}
```

---

# âœ… 4. ATOI (String to Integer)

```java
public class ATOI {

    // Brute Force: Parse char by char
    public static int myAtoiBrute(String s) {
        s = s.trim(); // remove leading spaces
        if (s.isEmpty()) return 0;

        int sign = 1, i = 0;
        if (s.charAt(0) == '-' || s.charAt(0) == '+') {
            sign = (s.charAt(0) == '-') ? -1 : 1;
            i++;
        }

        long num = 0;
        while (i < s.length() && Character.isDigit(s.charAt(i))) {
            num = num * 10 + (s.charAt(i) - '0');
            if (num * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;
            if (num * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;
            i++;
        }
        return (int)(num * sign);
    }
    // Time: O(n), Space: O(1)

    // Optimized: Same logic, but exit early if overflow
    public static int myAtoiOptimized(String s) {
        return myAtoiBrute(s); // Same efficiency here
    }

    public static void main(String[] args) {
        System.out.println(myAtoiBrute("   -42"));     // -42
        System.out.println(myAtoiOptimized("4193abc"));// 4193
    }
}
```

---

# âœ… 5. Staircase Pattern

```java
public class Staircase {

    // Brute Force: Nested loops
    public static void staircaseBrute(int n) {
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < n - i; j++) System.out.print(" ");
            for (int j = 0; j < i; j++) System.out.print("#");
            System.out.println();
        }
    }
    // Time: O(n^2), Space: O(1)

    // Optimized: Use String.repeat()
    public static void staircaseOptimized(int n) {
        for (int i = 1; i <= n; i++) {
            System.out.println(" ".repeat(n - i) + "#".repeat(i));
        }
    }
    // Time: O(n^2) (still printing chars), Space: O(1)

    public static void main(String[] args) {
        staircaseBrute(4);
        staircaseOptimized(5);
    }
}
```

---

# âœ… 6. Winner of Election

```java
import java.util.*;

public class ElectionWinner {

    // Brute Force: Count using loops
    public static String winnerBrute(String[] votes) {
        String winner = "";
        int maxCount = 0;
        for (String cand : votes) {
            int count = 0;
            for (String v : votes) {
                if (v.equals(cand)) count++;
            }
            if (count > maxCount || (count == maxCount && cand.compareTo(winner) < 0)) {
                maxCount = count;
                winner = cand;
            }
        }
        return winner;
    }
    // Time: O(n^2), Space: O(1)

    // Optimized: Use HashMap
    public static String winnerOptimized(String[] votes) {
        Map<String, Integer> map = new HashMap<>();
        for (String v : votes) map.put(v, map.getOrDefault(v, 0) + 1);

        String winner = "";
        int maxCount = 0;
        for (var e : map.entrySet()) {
            if (e.getValue() > maxCount || 
                (e.getValue() == maxCount && e.getKey().compareTo(winner) < 0)) {
                maxCount = e.getValue();
                winner = e.getKey();
            }
        }
        return winner;
    }
    // Time: O(n), Space: O(k) where k = distinct candidates

    public static void main(String[] args) {
        String[] votes1 = {"Alice", "Bob", "Alice", "Bob", "Alice"};
        String[] votes2 = {"John", "John", "Jane", "Jane", "Jane"};
        System.out.println(winnerBrute(votes1));      // Alice
        System.out.println(winnerOptimized(votes1));  // Alice
        System.out.println(winnerBrute(votes2));      // Jane
        System.out.println(winnerOptimized(votes2));  // Jane
    }
}
```

---

# âœ… 7. Top 10 Videos with Highest Watch Rates

```java
import java.util.*;

public class TopVideos {

    // Brute Force: Sort entire array
    public static List<Integer> top10Brute(int[] views) {
        Arrays.sort(views);
        List<Integer> result = new ArrayList<>();
        for (int i = views.length - 1; i >= Math.max(0, views.length - 10); i--) {
            result.add(views[i]);
        }
        return result;
    }
    // Time: O(n log n), Space: O(1)

    // Optimized: Use MinHeap of size 10
    public static List<Integer> top10Optimized(int[] views) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int v : views) {
            minHeap.add(v);
            if (minHeap.size() > 10) minHeap.poll();
        }
        List<Integer> result = new ArrayList<>(minHeap);
        result.sort(Collections.reverseOrder());
        return result;
    }
    // Time: O(n log 10) â‰ˆ O(n), Space: O(10)

    public static void main(String[] args) {
        int[] views1 = {5, 2, 8, 9, 15, 20, 7, 30, 40, 50, 1};
        int[] views2 = {100, 200, 50, 60, 300, 400, 10, 20, 700, 900, 1000, 1100};
        System.out.println(top10Brute(views1));       // [50, 40, 30, 20, 15, 9, 8, 7, 5, 2]
        System.out.println(top10Optimized(views2));   // [1100, 1000, 900, 700, 400, 300, 200, 100, 60, 50]
    }
}
```

---

# âœ… 8. Function Compose

```java
import java.util.function.Function;

public class FunctionCompose {

    // Brute Force: Apply functions manually
    public static int composeBrute(Function<Integer, Integer>[] funcs, int x) {
        for (int i = funcs.length - 1; i >= 0; i--) {
            x = funcs[i].apply(x);
        }
        return x;
    }
    // Time: O(k), Space: O(1)

    // Optimized: Use Java Function.compose()
    public static Function<Integer, Integer> composeOptimized(Function<Integer, Integer>[] funcs) {
        Function<Integer, Integer> res = Function.identity();
        for (int i = funcs.length - 1; i >= 0; i--) {
            res = res.compose(funcs[i]);
        }
        return res;
    }
    // Time: O(k), Space: O(1)

    public static void main(String[] args) {
        Function<Integer, Integer>[] funcs = new Function[]{
                x -> x + 1,
                x -> x * 2,
                x -> x - 3
        };

        System.out.println(composeBrute(funcs, 5)); // ((5 - 3) * 2) + 1 = 5
        System.out.println(composeOptimized(funcs).apply(5)); // 5
    }
}
```

---

ðŸ‘‰ Do you want me to **combine all problems into a single `Main.java` file** with each problem as a separate method/class (for easier testing), or keep them as **separate standalone programs** like above?
