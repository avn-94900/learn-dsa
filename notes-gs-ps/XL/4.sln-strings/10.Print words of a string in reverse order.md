Here’s a **complete guide** for the problem **“Print words of a string in reverse order”**. I’ll structure it exactly as requested.

---

## 1. Problem Statement & Example

**Problem:**
Given a string containing words separated by spaces, print the words in reverse order while keeping the words themselves intact.

**Input:**

```
"Hello world from Java"
```

**Output:**

```
"Java from world Hello"
```

**Notes:**

* Preserve spaces only as single separators between words.
* Leading and trailing spaces can be ignored or trimmed.

---

## 2. Approaches

### **Approach 1: Brute Force (Split & Iterate Backwards)**

**Logic:**

1. Split the string by spaces into an array of words.
2. Iterate from the last word to the first, appending to result.

**Time Complexity:** O(n) – iterate through string once to split + once to print.
**Space Complexity:** O(n) – to store words in array.

**When to use:** Simple, readable, works for most cases.

---

### **Approach 2: Using Stack**

**Logic:**

1. Split the string by spaces.
2. Push each word onto a stack.
3. Pop words from stack to get reversed order.

**Time Complexity:** O(n)
**Space Complexity:** O(n) – stack stores words

**When to use:** When you want to emphasize the LIFO approach or work with linked list / streaming words.

---

### **Approach 3: In-Place Reversal (Without Extra Data Structure)**

**Logic:**

1. Reverse the whole string.
2. Reverse each word in the reversed string.

**Example:**

* Input: `"Hello world"`
* Reverse whole string → `"dlrow olleH"`
* Reverse each word → `"world Hello"`

**Time Complexity:** O(n)
**Space Complexity:** O(n) or O(1) if mutable char array

**When to use:** Optimized for large inputs if modifying char array in place is allowed.

---

### **Approach 4: Recursive Method**

**Logic:**

1. Recursively extract the first word, then call function for the rest of string.
2. Append first word at the end of recursion result.

**Time Complexity:** O(n²) if using substring repeatedly.
**Space Complexity:** O(n) for recursion stack

**When to use:** Mainly academic or interview to show recursion usage.

---

### **Approach 5: Using Java Streams (Optimized)**

**Logic:**

1. Split string into words.
2. Use `Collections.reverse()` or `Stream API` to reverse array.
3. Join words with space.

**Time Complexity:** O(n)
**Space Complexity:** O(n)

**When to use:** Modern Java approach, concise and readable.

---

## 3. Comparison Table

| Approach                  | Time Complexity | Space Complexity | Pros                             | Cons                         |
| ------------------------- | --------------- | ---------------- | -------------------------------- | ---------------------------- |
| Split & iterate backwards | O(n)            | O(n)             | Simple, readable                 | Extra array                  |
| Stack                     | O(n)            | O(n)             | Demonstrates LIFO                | Slightly more memory         |
| In-place reversal         | O(n)            | O(n)/O(1)        | Space efficient (if char array)  | String immutability in Java  |
| Recursive                 | O(n²)           | O(n)             | Recursive solution demonstration | Slow for large strings       |
| Streams / Collections     | O(n)            | O(n)             | Concise, modern Java             | Less intuitive for beginners |

---

## 4. Java Code Implementations

### **Approach 1: Brute Force**

```java
public class ReverseWords {
    public static String reverseWords(String str) {
        if (str == null || str.isEmpty()) return str;
        String[] words = str.trim().split("\\s+");
        StringBuilder sb = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            sb.append(words[i]);
            if (i != 0) sb.append(" ");
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        System.out.println(reverseWords("Hello world from Java")); // Java from world Hello
    }
}
```

---

### **Approach 2: Using Stack**

```java
import java.util.Stack;

public class ReverseWordsStack {
    public static String reverseWords(String str) {
        if (str == null || str.isEmpty()) return str;
        String[] words = str.trim().split("\\s+");
        Stack<String> stack = new Stack<>();
        for (String word : words) stack.push(word);
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()) {
            sb.append(stack.pop());
            if (!stack.isEmpty()) sb.append(" ");
        }
        return sb.toString();
    }
}
```

---

### **Approach 3: In-Place Reversal (using char array)**

```java
public class ReverseWordsInPlace {
    public static String reverseWords(String s) {
        if (s == null || s.isEmpty()) return s;
        char[] str = s.toCharArray();
        reverse(str, 0, str.length - 1); // Reverse whole string
        int start = 0;
        for (int end = 0; end <= str.length; end++) {
            if (end == str.length || str[end] == ' ') {
                reverse(str, start, end - 1); // Reverse each word
                start = end + 1;
            }
        }
        return new String(str);
    }

    private static void reverse(char[] arr, int i, int j) {
        while (i < j) {
            char temp = arr[i];
            arr[i++] = arr[j];
            arr[j--] = temp;
        }
    }
}
```

---

### **Approach 4: Recursive**

```java
public class ReverseWordsRecursive {
    public static String reverseWords(String str) {
        str = str.trim();
        if (!str.contains(" ")) return str;
        int index = str.indexOf(" ");
        String first = str.substring(0, index);
        String rest = str.substring(index + 1);
        return reverseWords(rest) + " " + first;
    }
}
```

---

### **Approach 5: Using Streams**

```java
import java.util.Arrays;
import java.util.Collections;

public class ReverseWordsStream {
    public static String reverseWords(String str) {
        if (str == null || str.isEmpty()) return str;
        String[] words = str.trim().split("\\s+");
        Collections.reverse(Arrays.asList(words));
        return String.join(" ", words);
    }
}
```

---

## 5. Test Cases & Edge Cases

| Input                         | Output                    |
| ----------------------------- | ------------------------- |
| `"Hello world from Java"`     | `"Java from world Hello"` |
| `"   Leading and trailing  "` | `"trailing and Leading"`  |
| `"SingleWord"`                | `"SingleWord"`            |
| `""` (empty string)           | `""`                      |
| `"    "` (only spaces)        | `""`                      |
| `"Multiple   spaces   here"`  | `"here spaces Multiple"`  |
| `"a b c d"`                   | `"d c b a"`               |

---

## 6. Pitfalls & Best Practices

* **Common Mistakes:**

  * Not trimming spaces → extra spaces in output.
  * Using split without `\\s+` → multiple spaces may cause empty strings.
  * Recursive method may fail for large strings due to stack overflow.

* **Best Practices:**

  * Always `trim()` input.
  * Use `StringBuilder` for concatenation in loops.
  * Use `\\s+` in regex to handle multiple spaces.

---

## 7. Optional: JUnit Test Class (Optimized Approach)

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

public class ReverseWordsTest {

    @Test
    public void testNormalCase() {
        assertEquals("Java from world Hello", ReverseWords.reverseWords("Hello world from Java"));
    }

    @Test
    public void testLeadingTrailingSpaces() {
        assertEquals("trailing and Leading", ReverseWords.reverseWords("   Leading and trailing  "));
    }

    @Test
    public void testSingleWord() {
        assertEquals("SingleWord", ReverseWords.reverseWords("SingleWord"));
    }

    @Test
    public void testEmptyString() {
        assertEquals("", ReverseWords.reverseWords(""));
    }

    @Test
    public void testMultipleSpaces() {
        assertEquals("here spaces Multiple", ReverseWords.reverseWords("Multiple   spaces   here"));
    }
}
```

---

## 8. Related / Follow-Up Questions

1. Reverse words in-place **without extra space** for huge strings.
2. Reverse only **first k words**.
3. Reverse words **keeping punctuation** in original places.
4. Count **words before reversing**.
5. Reverse words in **linked list** representation.
6. Reverse words **using recursion** without splitting.

---

If you want, I can **draw a simple diagram showing all 5 approaches visually** with **flow of operations**, which helps for interview explanation.

Do you want me to create that diagram?
