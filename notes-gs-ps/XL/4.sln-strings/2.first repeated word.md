Great question üöÄ Let‚Äôs build a **complete structured solution** for **‚ÄúFind the First Repeated Word in a String‚Äù** step by step.

---

# 1. Problem Statement & Example

**Problem:**
Given a string of words separated by spaces (or punctuation), find the **first word that repeats** when scanning left to right.

* Ignore case sensitivity (optional, depends on requirement).
* Words are sequences of alphabets/numbers (punctuation should be ignored if required).

**Example 1:**

```
Input: "This is a test and this test is simple"
Output: "this"  
Explanation: The first repeated word is "this" (appears again after first).
```

**Example 2:**

```
Input: "one two three four five"
Output: No Repetition  
Explanation: No word repeats.
```

---

# 2. Approaches

### **Approach A ‚Äì Brute Force (Nested Loops)**

* For each word, scan all subsequent words to check for duplicates.
* Return the first repeated word found.

**Complexity:**

* Time: **O(n¬≤)** (n = number of words).
* Space: **O(1)** (no extra data structure).
* Use when input size is very small.

---

### **Approach B ‚Äì Using HashSet (Optimized)**

* Traverse words left to right.
* Maintain a **HashSet** of seen words.
* If a word is already in the set ‚Üí return it immediately.

**Complexity:**

* Time: **O(n)**
* Space: **O(n)**
* Best for large input.

---

### **Approach C ‚Äì Using HashMap (Count Frequency)**

* Count frequency of each word in a HashMap.
* Then traverse again to find the first word with count > 1.

**Complexity:**

* Time: **O(n)** (two passes).
* Space: **O(n)**
* Useful when also required to know *all repeated words*.

---

### **Approach D ‚Äì Stream / Functional (Java 8)**

* Use `LinkedHashSet` or streams with filtering.
* Concise but similar logic to HashSet.

**Complexity:**

* Same as HashSet approach.

---

### **Approach E ‚Äì Recursive (For Learning)**

* Recursively check word list with a HashSet passed along.
* Not efficient in Java (stack overhead).

**Complexity:**

* Same as HashSet but with recursion overhead.

---

# 3. Comparison Table

| Approach    | Time Complexity | Space Complexity | Pros                   | Cons                 |
| ----------- | --------------- | ---------------- | ---------------------- | -------------------- |
| Brute Force | O(n¬≤)           | O(1)             | Simple, no DS needed   | Slow for large input |
| HashSet     | O(n)            | O(n)             | Fast, single pass      | Needs extra space    |
| HashMap     | O(n)            | O(n)             | Tracks all frequencies | Two passes           |
| Stream/DS   | O(n)            | O(n)             | Concise, modern Java   | Less explicit        |
| Recursive   | O(n)            | O(n) (stack+set) | Good for practice      | Inefficient in Java  |

---

# 4. Code (Java Implementations)

```java
import java.util.*;

public class FirstRepeatedWord {

    // ---------- Approach A: Brute Force ----------
    public static String firstRepeatedBruteForce(String str) {
        String[] words = str.toLowerCase().split("\\W+"); // split ignoring punctuation
        for (int i = 0; i < words.length; i++) {
            for (int j = i + 1; j < words.length; j++) {
                if (words[i].equals(words[j])) {
                    return words[i];
                }
            }
        }
        return "No Repetition";
    }

    // ---------- Approach B: HashSet ----------
    public static String firstRepeatedHashSet(String str) {
        String[] words = str.toLowerCase().split("\\W+");
        Set<String> seen = new HashSet<>();
        for (String word : words) {
            if (seen.contains(word)) {
                return word;
            }
            seen.add(word);
        }
        return "No Repetition";
    }

    // ---------- Approach C: HashMap ----------
    public static String firstRepeatedHashMap(String str) {
        String[] words = str.toLowerCase().split("\\W+");
        Map<String, Integer> freq = new HashMap<>();
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }
        for (String word : words) {
            if (freq.get(word) > 1) return word;
        }
        return "No Repetition";
    }

    // ---------- Approach D: Java 8 Stream ----------
    public static String firstRepeatedStream(String str) {
        String[] words = str.toLowerCase().split("\\W+");
        Set<String> seen = new HashSet<>();
        return Arrays.stream(words)
                .filter(w -> !seen.add(w)) // if add() returns false ‚Üí already exists
                .findFirst()
                .orElse("No Repetition");
    }

    // ---------- Approach E: Recursive ----------
    public static String firstRepeatedRecursive(String[] words, int index, Set<String> seen) {
        if (index >= words.length) return "No Repetition";
        if (seen.contains(words[index])) return words[index];
        seen.add(words[index]);
        return firstRepeatedRecursive(words, index + 1, seen);
    }
}
```

---

# 5. Test Cases & Edge Cases

| Input                                      | Expected Output                    |
| ------------------------------------------ | ---------------------------------- |
| `"This is a test and this test is simple"` | `"this"`                           |
| `"one two three four"`                     | `"No Repetition"`                  |
| `"Hello hello world"`                      | `"hello"` (case-insensitive)       |
| `"Repeat repeat repeat"`                   | `"repeat"`                         |
| `"a a b b"`                                | `"a"`                              |
| `""`                                       | `"No Repetition"` (empty string)   |
| `"!!! ??? !!!"`                            | `"No Repetition"` (no valid words) |
| `"word"`                                   | `"No Repetition"` (single word)    |

---

# 6. Pitfalls

* **Case sensitivity** ‚Üí Decide if "Hello" and "hello" are same.
* **Punctuation handling** ‚Üí Use regex (`\\W+`) to split words properly.
* **Empty strings** ‚Üí Avoid `ArrayIndexOutOfBounds`.
* **Large input** ‚Üí Use HashSet approach for efficiency.

---

# 7. (Optional) JUnit Test Class

```java
import org.junit.Test;
import static org.junit.Assert.*;
import java.util.*;

public class FirstRepeatedWordTest {

    @Test
    public void testHashSetApproach() {
        assertEquals("this", FirstRepeatedWord.firstRepeatedHashSet("This is a test and this test is simple"));
        assertEquals("No Repetition", FirstRepeatedWord.firstRepeatedHashSet("one two three four"));
        assertEquals("hello", FirstRepeatedWord.firstRepeatedHashSet("Hello hello world"));
        assertEquals("repeat", FirstRepeatedWord.firstRepeatedHashSet("Repeat repeat repeat"));
        assertEquals("a", FirstRepeatedWord.firstRepeatedHashSet("a a b b"));
        assertEquals("No Repetition", FirstRepeatedWord.firstRepeatedHashSet(""));
        assertEquals("No Repetition", FirstRepeatedWord.firstRepeatedHashSet("!!! ??? !!!"));
        assertEquals("No Repetition", FirstRepeatedWord.firstRepeatedHashSet("word"));
    }
}
```

---

# 8. Related / Follow-Up Questions

* Find the **first non-repeated word** instead of repeated.
* Find **all repeated words** and their counts.
* Find the **most frequent word**.
* Input as **array of strings** or **linked list of words**.
* Solve with **parallel streams** for very large input.
* Modify to return the **index** (position) of repeated word.

---


<br/><br/><br/>

Great catch üëç You‚Äôre asking specifically about the **`String.split(String regex)`** function in Java, what kinds of arguments (regex patterns) we can pass to it, and what outputs we‚Äôd get. Let‚Äôs break it down.

---

## 1. Reminder: How `split()` Works

* **Signature:**

  ```java
  public String[] split(String regex)
  public String[] split(String regex, int limit)
  ```
* It splits the string around matches of the **regex**.
* The argument is not just a literal string ‚Üí it‚Äôs a **regular expression**.
* Returns an array of substrings.

---

## 2. Commonly Used Regex Variants

### (a) **Split on whitespace**

```java
str.split("\\s+");
```

* Splits on one or more whitespace characters (space, tab, newline).
* `"one   two\nthree".split("\\s+")`
  ‚Üí `["one", "two", "three"]`

---

### (b) **Split on non-word characters**

```java
str.split("\\W+");
```

* `\W` = any character that is *not* a letter, digit, or underscore.
* `"hello, world!! test123".split("\\W+")`
  ‚Üí `["hello", "world", "test123"]`

---

### (c) **Split on commas**

```java
str.split(",");
```

* `"a,b,c,d".split(",")`
  ‚Üí `["a", "b", "c", "d"]`

---

### (d) **Split on multiple delimiters (regex OR)**

```java
str.split("[,;\\s]+");
```

* Splits on comma, semicolon, or whitespace.
* `"a,b; c d".split("[,;\\s]+")`
  ‚Üí `["a", "b", "c", "d"]`

---

### (e) **Split into individual characters**

```java
str.split("");
```

* `"hello".split("")`
  ‚Üí `["h", "e", "l", "l", "o"]`
  *(Note: First element may be empty if string starts with character, depends on Java version.)*

---

### (f) **Split on digits**

```java
str.split("\\d+");
```

* `"abc123def45ghi".split("\\d+")`
  ‚Üí `["abc", "def", "ghi"]`

---

### (g) **Split on exact string (no regex)**

```java
str.split("\\Q::\\E");
```

* `\\Q ... \\E` treats text literally (ignores regex meta-characters).
* `"a::b::c".split("\\Q::\\E")`
  ‚Üí `["a", "b", "c"]`

---

### (h) **Split by start or end of line**

```java
str.split("^|$");
```

* `"abc".split("^|$")`
  ‚Üí `["", "abc", ""]` (splits at beginning and end).

---

### (i) **Split with limit parameter**

```java
str.split("\\s+", 2);
```

* `"one two three".split("\\s+", 2)`
  ‚Üí `["one", "two three"]`
* Limit keeps remainder intact.

---

## 3. Comparison of `\\W+` vs `\\s+`

| Regex  | Meaning                                                | Example Input  | Output                 |
| ------ | ------------------------------------------------------ | -------------- | ---------------------- |
| `\\s+` | Splits on whitespace (spaces, tabs, newlines)          | `"a b\tc\n d"` | `["a", "b", "c", "d"]` |
| `\\W+` | Splits on non-word chars (punctuation, space, symbols) | `"a,b!c d"`    | `["a", "b", "c", "d"]` |

* `\\s+` is **stricter**: splits only on spacing.
* `\\W+` is **broader**: splits on punctuation, symbols, spaces.

---

## 4. Quick Reference Table

| Regex        | Splits On               | Example `"a,b c;d123e"` ‚Üí Result |
| ------------ | ----------------------- | -------------------------------- |
| `" "`        | single space            | `["a,b", "c;d123e"]`             |
| `"\\s+"`     | whitespace              | `["a,b", "c;d123e"]`             |
| `"\\W+"`     | non-word chars          | `["a", "b", "c", "d123e"]`       |
| `","`        | commas                  | `["a", "b c;d123e"]`             |
| `"[;\\s,]+"` | semicolon, space, comma | `["a", "b", "c", "d123e"]`       |
| `"\\d+"`     | digits                  | `["a,b c;d", "e"]`               |

---

‚úÖ Best practice:

* Use `split("\\W+")` if you want **words only** (ignore punctuation).
* Use `split("\\s+")` if you just want to split by whitespace (keep punctuation as part of words).

