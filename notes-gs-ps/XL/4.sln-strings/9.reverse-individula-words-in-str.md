
```java
public class ReverseWords {
    public static String reverseWords(String str) {
        if (str == null || str.isEmpty()) return str;

        // Split by whitespace (handles multiple spaces too)
        String[] words = str.trim().split("\\s+");
        StringBuilder sb = new StringBuilder();

        // Iterate in forward order (to keep word order intact)
        for (int i = 0; i < words.length; i++) {
            // Reverse each word using StringBuilder
            sb.append(new StringBuilder(words[i]).reverse());
            if (i != words.length - 1) sb.append(" ");
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        System.out.println(reverseWords("Hello world from Java")); 
        // Output: olleH dlrow morf avaJ
    }
}

```


Got it ðŸ‘ You want to **reverse individual words in a string** (not the order of words, but each word itself) using an **optimized approach**. Letâ€™s break this down step by step.

---

## 1. **Problem Statement**

Given a string `s`, reverse every individual word while keeping the word order intact.

ðŸ”¹ Example

```
Input:  "Hello World from Java"
Output: "olleH dlroW morf avaJ"
```

---

## 2. **Optimized Approach**

Instead of splitting and reconstructing (which creates extra arrays/strings), we can:

1. Convert the string to a **mutable character array**.
2. Traverse the array, reversing each word in-place:

   * Track word boundaries using indices.
   * Reverse characters between `start` and `end` when we hit a space or end of string.
3. Return the new string.

This avoids extra space beyond the character array.
**Time Complexity:** O(n) (every char processed once).
**Space Complexity:** O(1) (in-place, ignoring input/output string storage).

---

## 3. **Java Implementation**

```java
public class ReverseWordsInPlace {
    public static String reverseWords(String str) {
        if (str == null || str.isEmpty()) return str;

        char[] chars = str.toCharArray();
        int start = 0;

        for (int i = 0; i <= chars.length; i++) {
            if (i == chars.length || chars[i] == ' ') {
                reverse(chars, start, i - 1);
                start = i + 1;
            }
        }

        return new String(chars);
    }

    private static void reverse(char[] arr, int left, int right) {
        while (left < right) {
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }

    public static void main(String[] args) {
        System.out.println(reverseWords("Hello world from Java"));
        // Output: olleH dlrow morf avaJ
    }
}

```

---

âœ… This approach is:

* **In-place** (no extra splitting).
* **O(n) time** (single scan).
* **Optimized for memory** (only char array).

---

Do you want me to also show you a **one-liner Java Streams** solution (less optimal but more elegant), so you can compare readability vs performance?
