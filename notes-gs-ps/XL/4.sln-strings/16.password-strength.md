













---


## Check Strength of a Password

### ‚úÖ Problem

Check if a password is **strong**.
Strong password rules:

* At least **8 characters**
* Contains **uppercase**, **lowercase**, **digit**, **special char**

### üìò Approach

* Loop once ‚Üí track flags.
* Return `true` if all conditions met.

### ‚è± Complexity

* Time: **O(n)**
* Space: **O(1)**

### üíª Code

```java
public class PasswordStrengthChecker {
    public static boolean isStrongPassword(String password) {
        if (password.length() < 8) return false;

        boolean hasUpper = false, hasLower = false, hasDigit = false, hasSpecial = false;

        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) hasUpper = true;
            else if (Character.isLowerCase(c)) hasLower = true;
            else if (Character.isDigit(c)) hasDigit = true;
            else hasSpecial = true; // any non-alphanumeric char
        }

        return hasUpper && hasLower && hasDigit && hasSpecial;
    }

    public static void main(String[] args) {
        String pwd = "Strong@123";
        System.out.println("Is strong password? " + isStrongPassword(pwd));
    }
}
```

---

## **16. Check Strength of a Password**

### Problem Statement
Check password strength based on various criteria like length, uppercase/lowercase letters, digits, and special characters. Return strength level and missing requirements.

### Brute Force Approach: Multiple Separate Checks
```java
public class PasswordStrengthBruteForce {
    public static class StrengthResult {
        String strength;
        String[] missingRequirements;
        int score;
        
        StrengthResult(String strength, String[] missing, int score) {
            this.strength = strength;
            this.missingRequirements = missing;
            this.score = score;
        }
        
        @Override
        public String toString() {
            return String.format("Strength: %s (Score: %d/5)\nMissing: %s", 
                               strength, score, String.join(", ", missingRequirements));
        }
    }
    
    public static StrengthResult checkPasswordStrength(String password) {
        if (password == null || password.isEmpty()) {
            return new StrengthResult("Invalid", List.of("Password cannot be null or empty"), 0, false);
        }
        
        // Single pass through password to check all criteria
        boolean hasMinLength = password.length() >= 8;
        boolean hasUppercase = false;
        boolean hasLowercase = false;
        boolean hasDigit = false;
        boolean hasSpecial = false;
        
        String specialChars = "!@#$%^&*()_+-=[]{}|;:,.<>?";
        
        // Check all criteria in single pass
        for (char ch : password.toCharArray()) {
            if (!hasUppercase && Character.isUpperCase(ch)) {
                hasUppercase = true;
            } else if (!hasLowercase && Character.isLowerCase(ch)) {
                hasLowercase = true;
            } else if (!hasDigit && Character.isDigit(ch)) {
                hasDigit = true;
            } else if (!hasSpecial && specialChars.indexOf(ch) != -1) {
                hasSpecial = true;
            }
            
            // Early termination if all criteria met
            if (hasUppercase && hasLowercase && hasDigit && hasSpecial) {
                break;
            }
        }
        
        // Calculate score and determine missing requirements
        int score = 0;
        List<String> missing = new ArrayList<>();
        
        if (hasMinLength) score++; else missing.add("Minimum 8 characters");
        if (hasUppercase) score++; else missing.add("Uppercase letter");
        if (hasLowercase) score++; else missing.add("Lowercase letter");
        if (hasDigit) score++; else missing.add("Digit");
        if (hasSpecial) score++; else missing.add("Special character");
        
        // Determine strength level
        String strength = switch (score) {
            case 5 -> "Very Strong";
            case 4 -> "Strong";
            case 3 -> "Medium";
            case 2 -> "Weak";
            default -> "Very Weak";
        };
        
        return new StrengthResult(strength, missing, score, true);
    }
    
    // Advanced password strength checker with additional criteria
    public static StrengthResult checkPasswordStrengthAdvanced(String password) {
        if (password == null || password.isEmpty()) {
            return new StrengthResult("Invalid", List.of("Password cannot be null or empty"), 0, false);
        }
        
        boolean hasMinLength = password.length() >= 8;
        boolean hasGoodLength = password.length() >= 12; // Bonus for longer passwords
        boolean hasUppercase = false;
        boolean hasLowercase = false;
        boolean hasDigit = false;
        boolean hasSpecial = false;
        boolean hasNoCommonPatterns = !hasCommonPatterns(password);
        boolean hasNoRepeatingChars = !hasRepeatingCharacters(password);
        
        String specialChars = "!@#$%^&*()_+-=[]{}|;:,.<>?";
        
        for (char ch : password.toCharArray()) {
            if (!hasUppercase && Character.isUpperCase(ch)) hasUppercase = true;
            else if (!hasLowercase && Character.isLowerCase(ch)) hasLowercase = true;
            else if (!hasDigit && Character.isDigit(ch)) hasDigit = true;
            else if (!hasSpecial && specialChars.indexOf(ch) != -1) hasSpecial = true;
        }
        
        // Advanced scoring system
        int score = 0;
        List<String> missing = new ArrayList<>();
        
        if (hasMinLength) score++; else missing.add("Minimum 8 characters");
        if (hasUppercase) score++; else missing.add("Uppercase letter");
        if (hasLowercase) score++; else missing.add("Lowercase letter");
        if (hasDigit) score++; else missing.add("Digit");
        if (hasSpecial) score++; else missing.add("Special character");
        
        // Bonus points
        if (hasGoodLength) score++; else missing.add("12+ characters recommended");
        if (hasNoCommonPatterns) score++; else missing.add("Avoid common patterns");
        if (hasNoRepeatingChars) score++; else missing.add("Avoid repeating characters");
        
        String strength = switch (score) {
            case 8, 7 -> "Excellent";
            case 6 -> "Very Strong";
            case 5 -> "Strong";
            case 4 -> "Medium";
            case 3 -> "Weak";
            default -> "Very Weak";
        };
        
        return new StrengthResult(strength, missing, Math.min(score, 5), true);
    }
    
    private static boolean hasCommonPatterns(String password) {
        String lower = password.toLowerCase();
        String[] commonPatterns = {"123", "abc", "password", "admin", "user", "qwerty"};
        
        for (String pattern : commonPatterns) {
            if (lower.contains(pattern)) return true;
        }
        return false;
    }
    
    private static boolean hasRepeatingCharacters(String password) {
        for (int i = 0; i < password.length() - 2; i++) {
            if (password.charAt(i) == password.charAt(i + 1) && 
                password.charAt(i + 1) == password.charAt(i + 2)) {
                return true;
            }
        }
        return false;
    }
    
    public static void main(String[] args) {
        String[] passwords = {"weak", "StrongPass1!", "VeryStr0ng!Password", "aaaaaa"};
        
        for (String pwd : passwords) {
            System.out.println("Password: " + pwd);
            System.out.println(checkPasswordStrength(pwd));
            System.out.println("---");
        }
    }
}
```
**Time Complexity:** O(n) - single pass through password string  
**Space Complexity:** O(1) - constant extra space for flags and small list  
**Explanation:** Single pass is more efficient; early termination when all criteria met; advanced version includes bonus criteria

---